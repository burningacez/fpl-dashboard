<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <link rel="icon" type="image/png" href="/favicon.png">
    <link rel="apple-touch-icon" href="/favicon-192.png">
    <link rel="manifest" href="/manifest.json">
    <title>Scores - FPL League</title>
    <link rel="stylesheet" href="/styles.css">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        /* Full viewport layout - no page scroll, table scrolls independently.
           100svh = "small viewport height" which is the visible area when all
           browser chrome (URL bar, toolbar) is fully expanded. This guarantees
           content is never clipped behind browser UI or system nav bars.
           100vh is the fallback for browsers that don't support svh. */
        html {
            height: 100vh;
            height: 100svh;
            overflow: hidden;
        }
        body {
            height: 100%;
            min-height: 0; /* override styles.css min-height:100vh which extends behind browser/nav bars */
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        .navbar { flex-shrink: 0; }
        .api-status-banner { flex-shrink: 0; }
        .page-header { flex-shrink: 0; }
        main {
            flex: 1;
            min-height: 0;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            padding-top: var(--space-2);
            padding-bottom: 0;
        }
        #content {
            flex: 1;
            min-height: 0;
            display: flex;
            flex-direction: column;
        }
        #ticker-area {
            flex-shrink: 0;
            /* Account for Chrome 135+ edge-to-edge gesture nav and notches */
            padding-bottom: env(safe-area-inset-bottom, 0px);
        }
        #ticker-area .ticker-container {
            margin-bottom: 0;
            border-radius: 8px 8px 0 0;
        }

        th.sortable { cursor: pointer; user-select: none; }
        th.sortable:hover { background: rgba(255,255,255,0.1); }
        th.sortable.asc::after { content: ' \2191'; opacity: 0.7; }
        th.sortable.desc::after { content: ' \2193'; opacity: 0.7; }

        /* Table layout - fixed widths for even, predictable columns */
        .table-container {
            flex: 1;
            min-height: 0;
            overflow-y: auto;
            overflow-x: auto;
        }

        .table-container table {
            width: 100%;
            table-layout: fixed;
        }

        .table-container thead th {
            position: sticky;
            top: 0;
            z-index: 2;
            background: var(--primary);
        }

        .table-container th,
        .table-container td {
            padding: 0.6rem 0.4rem;
        }

        .table-container th {
            font-size: 0.65rem;
        }

        .table-container td {
            font-size: 0.78rem;
        }

        .table-container .col-manager {
            text-align: left;
            padding-left: 0.5rem;
            overflow: hidden;
        }

        .table-container .col-manager strong,
        .table-container .col-manager .team-name {
            display: block;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .table-container .captain-cell,
        .table-container .col-captain {
            text-align: left;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .table-container .rank-cell {
            font-size: 0.85rem;
        }

        .table-container .rank-1 {
            font-size: 0.95rem;
        }

        .table-container td.captain-cell {
            font-size: 0.78rem;
        }

        .table-container .team-name {
            font-size: 0.68rem;
        }

        .table-container .vice-captain {
            font-size: 0.65rem;
            color: rgba(255, 255, 255, 0.5);
            margin-top: 0.1rem;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .table-container th.num,
        .table-container td.num {
            white-space: nowrap;
        }

        .table-container td.num .event-impact {
            display: block;
            margin-left: 0;
            margin-top: 2px;
        }

        .table-container td.num .transfer-cost {
            display: block;
            font-size: 0.7rem;
            margin-top: 1px;
        }

        @media (max-width: 480px) {
            .table-container th,
            .table-container td {
                padding: 0.5rem 0.25rem;
            }
            .table-container td {
                font-size: 0.75rem;
            }
            .table-container .rank-cell {
                font-size: 0.8rem;
            }
            .table-container .rank-1 {
                font-size: 0.85rem;
            }
            .table-container .team-name {
                font-size: 0.65rem;
            }
            .table-container td.captain-cell {
                font-size: 0.75rem;
            }
            .table-container .vice-captain {
                font-size: 0.6rem;
            }
        }

        .live-indicator {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            background: var(--danger);
            color: var(--white);
            padding: 0.4rem 0.85rem;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 700;
        }

        .live-indicator::before {
            content: '';
            width: 8px;
            height: 8px;
            background: var(--white);
            border-radius: 50%;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(0.8); }
        }

        .last-updated {
            font-size: 0.85rem;
            color: rgba(255, 255, 255, 0.6);
        }

        .chip-badge {
            display: inline-block;
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: 700;
        }
        .chip-badge.wildcard { background: #9b59b6; color: white; }
        .chip-badge.freehit { background: #3498db; color: white; }
        .chip-badge.bboost { background: #e67e22; color: white; }
        .chip-badge.tc { background: #27ae60; color: white; }

        /* Manager info pills under team name */
        .manager-pills {
            display: flex;
            gap: 0.35rem;
            margin-top: 0.35rem;
            flex-wrap: wrap;
        }
        .info-pill {
            display: inline-block;
            padding: 0.15rem 0.4rem;
            border-radius: 3px;
            font-size: 0.65rem;
            font-weight: 600;
            line-height: 1.2;
        }
        .chip-pill.wildcard { background: #9b59b6; color: white; }
        .chip-pill.freehit { background: #3498db; color: white; }
        .chip-pill.bboost { background: #e67e22; color: white; }
        .chip-pill.tc { background: #27ae60; color: white; }
        .left-pill { background: rgba(255, 255, 255, 0.15); color: rgba(255, 255, 255, 0.7); }

        /* Modal - Clean FPL App Style */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            align-items: flex-start;
            justify-content: center;
            z-index: 1000;
            padding: 0;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s;
            overflow-y: auto;
        }

        .modal-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .modal {
            background: #f5f5f5;
            border-radius: 0;
            width: 100%;
            min-height: 100%;
            overflow: visible;
            display: flex;
            flex-direction: column;
            transform: scale(0.95);
            transition: transform 0.3s;
        }

        @media (min-width: 500px) {
            .modal-overlay {
                padding: 1rem;
                align-items: center;
            }
            .modal {
                max-width: 480px;
                border-radius: 20px;
                min-height: auto;
                max-height: 90vh;
                overflow: hidden;
            }
            .modal .modal-body {
                overflow-y: auto;
            }
        }

        @media (min-width: 768px) {
            .modal {
                max-width: 520px;
            }
        }

        .modal-overlay.active .modal {
            transform: scale(1);
        }

        .modal-header {
            background: linear-gradient(135deg, var(--primary) 0%, var(--primary-light) 100%);
            padding: 1rem 1.5rem;
            padding-top: 2.5rem;
            position: relative;
            border-bottom: none;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-header-info {
            flex: 1;
            min-width: 0;
        }

        .modal-header h2 {
            font-size: 1.3rem;
            font-weight: 700;
            color: #fff;
            margin: 0;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .modal-header .team-name {
            font-size: 0.85rem;
            color: rgba(255, 255, 255, 0.7);
            margin-top: 0.2rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .modal-points {
            font-size: 2.8rem;
            font-weight: 800;
            color: var(--accent);
            line-height: 1;
            margin-right: 2.5rem;
            flex-shrink: 0;
        }

        .modal-close {
            position: absolute;
            top: 0.75rem;
            right: 0.75rem;
            background: rgba(255, 255, 255, 0.2);
            border: none;
            font-size: 1.5rem;
            color: #fff;
            cursor: pointer;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
        }

        .modal-close:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .modal-body {
            flex: 1;
            overflow-y: visible;
            padding: 0;
            background: var(--gray-900);
            overscroll-behavior: contain;
        }

        @media (min-width: 500px) {
            .modal-body {
                overflow-y: auto;
            }
        }

        /* Pitch - Full Width with green stripes */
        .pitch-container {
            background: linear-gradient(180deg,
                #3d9140 0%, #348f37 10%,
                #3d9140 10%, #348f37 20%,
                #3d9140 20%, #348f37 30%,
                #3d9140 30%, #348f37 40%,
                #3d9140 40%, #348f37 50%,
                #3d9140 50%, #348f37 60%,
                #3d9140 60%, #348f37 70%,
                #3d9140 70%, #348f37 80%,
                #3d9140 80%, #348f37 90%,
                #3d9140 90%, #348f37 100%
            );
            padding: 0.75rem 0;
            position: relative;
            border-radius: 0;
            margin: 0;
            width: 100%;
        }

        .pitch-markings {
            position: absolute;
            inset: 0.5rem 1rem;
            border: 2px solid rgba(255,255,255,0.35);
            pointer-events: none;
        }

        .pitch-center {
            position: absolute;
            left: 50%;
            top: 50%;
            width: 50px;
            height: 50px;
            border: 2px solid rgba(255,255,255,0.35);
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }

        .pitch-halfway {
            position: absolute;
            left: 0;
            right: 0;
            top: 50%;
            height: 2px;
            background: rgba(255,255,255,0.35);
        }

        .pitch-box-top {
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 120px;
            height: 35px;
            border: 2px solid rgba(255,255,255,0.35);
            border-top: none;
        }

        .pitch-box-bottom {
            position: absolute;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 120px;
            height: 35px;
            border: 2px solid rgba(255,255,255,0.35);
            border-bottom: none;
        }

        .formation-row {
            display: flex;
            justify-content: center;
            gap: 2px;
            padding: 0.5rem 0;
            position: relative;
            z-index: 1;
        }

        .formation-row.gk { padding-top: 0.5rem; }
        .formation-row.fwd { padding-bottom: 0.5rem; }

        /* Player Card - Transparent, sized for 5 across with bigger shirts */
        .player-card {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: calc((100vw - 10px) / 5);
            max-width: 100px;
            min-width: 68px;
            cursor: pointer;
            position: relative;
            background: transparent;
            padding: 2px 0;
        }

        @media (min-width: 500px) {
            .player-card {
                width: calc((500px - 20px) / 5);
                max-width: 96px;
            }
        }

        .player-card.subbed-out {
            opacity: 0.35;
        }

        .player-card.subbed-in::before {
            content: 'â†‘';
            position: absolute;
            top: 0;
            left: 0;
            background: #27ae60;
            color: white;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            font-size: 0.55rem;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
        }

        /* Shirt image - inflated for better visibility */
        .player-shirt {
            width: 57px;
            height: 57px;
            position: relative;
            margin-bottom: 2px;
        }

        .player-shirt img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.4));
        }

        .captain-badge {
            position: absolute;
            bottom: 0;
            right: -4px;
            width: 15px;
            height: 15px;
            background: #000;
            color: white;
            border-radius: 50%;
            font-size: 0.55rem;
            font-weight: 700;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1.5px solid white;
            z-index: 5;
        }

        .tc-badge {
            position: absolute;
            bottom: 0;
            right: -4px;
            width: 15px;
            height: 15px;
            background: linear-gradient(135deg, #27ae60, #1e8449);
            color: white;
            border-radius: 50%;
            font-size: 0.45rem;
            font-weight: 700;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1.5px solid white;
            z-index: 5;
        }

        .vice-badge {
            position: absolute;
            bottom: 0;
            right: -4px;
            width: 15px;
            height: 15px;
            background: #666;
            color: white;
            border-radius: 50%;
            font-size: 0.5rem;
            font-weight: 700;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1.5px solid white;
            z-index: 5;
        }

        /* Player name - no background, clean text */
        .player-name-box {
            padding: 1px 3px;
            margin-bottom: 1px;
            max-width: 100%;
        }

        .player-name {
            font-family: 'Inter', sans-serif;
            font-size: 0.66rem;
            font-weight: 700;
            color: #fff;
            text-align: center;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: calc((100vw - 10px) / 5 - 8px);
            display: block;
            letter-spacing: -0.3px;
            text-shadow: 0 1px 3px rgba(0,0,0,0.8), 0 0 8px rgba(0,0,0,0.5);
        }

        @media (min-width: 500px) {
            .player-name {
                max-width: 80px;
            }
        }

        .player-points-pill {
            background: transparent;
            color: #fff;
            padding: 1px 5px;
            font-size: 0.77rem;
            font-weight: 800;
            min-width: 22px;
            text-align: center;
            text-shadow: 0 1px 3px rgba(0,0,0,0.8), 0 0 6px rgba(0,0,0,0.5);
        }

        .player-points-pill.not-played {
            color: rgba(255,255,255,0.6);
            font-size: 0.55rem;
        }

        /* DGW: show both opponents comma-separated */
        .player-points-pill.dgw-opponents {
            font-size: 0.5rem;
            letter-spacing: -0.3px;
        }

        /* DGW: split display "pts | OPP" */
        .player-points-pill.dgw-split {
            font-size: 0.65rem;
            white-space: nowrap;
        }

        .dgw-separator {
            color: rgba(255,255,255,0.4);
            margin: 0 1px;
            font-weight: 400;
        }

        .dgw-next-opp {
            color: rgba(255,255,255,0.6);
            font-size: 0.5rem;
            font-weight: 600;
        }

        /* Yellow border for active match */
        .player-card.playing {
            border: 2px solid #ffc107;
            border-radius: 6px;
            box-shadow: 0 0 8px rgba(255, 193, 7, 0.5);
        }

        /* Faded for finished matches */
        .player-card.finished {
            opacity: 0.6;
        }

        .provisional-bonus {
            font-size: 0.5rem;
            color: #00ff85;
            margin-left: 1px;
            font-weight: 600;
        }

        /* Provisional bonus in match modal player rows */
        .player-pts .provisional-bonus {
            font-size: 0.6rem;
            vertical-align: super;
        }

        .player-events {
            display: flex;
            gap: 1px;
            margin-top: 1px;
            font-size: 0.5rem;
        }

        /* Bench Area */
        .bench-container {
            background: var(--gray-800);
            padding: 0.5rem 0.75rem;
        }

        .bench-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.4rem;
        }

        .bench-label {
            font-size: 0.7rem;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.6);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .bench-points {
            font-size: 0.75rem;
            font-weight: 700;
            color: rgba(255, 255, 255, 0.5);
        }

        .bench-row {
            display: flex;
            justify-content: space-around;
        }

        .bench-slot {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .bench-slot .player-card {
            width: calc((100vw - 10px) / 5);
            max-width: 100px;
            min-width: 68px;
        }

        .bench-slot .player-shirt {
            width: 57px;
            height: 57px;
        }

        .bench-slot .player-name {
            max-width: calc((100vw - 10px) / 5 - 8px);
            font-size: 0.66rem;
        }

        .bench-slot .player-points-pill {
            font-size: 0.77rem;
            padding: 1px 5px;
        }

        .bench-position {
            font-size: 0.6rem;
            color: rgba(255, 255, 255, 0.5);
            margin-bottom: 0.2rem;
            font-weight: 600;
        }

        /* Formation Label */
        .formation-bar {
            background: var(--gray-800);
            padding: 0.5rem;
            text-align: center;
            font-size: 0.85rem;
            color: rgba(255, 255, 255, 0.7);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .formation-bar strong {
            color: var(--accent);
        }

        /* Tooltip */
        .tooltip {
            position: fixed;
            background: #333;
            color: white;
            padding: 0.75rem 1rem;
            border-radius: 8px;
            font-size: 0.8rem;
            z-index: 2000;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            white-space: nowrap;
        }

        .tooltip.visible {
            opacity: 1;
        }

        .tooltip-header {
            font-weight: 700;
            margin-bottom: 0.5rem;
            border-bottom: 1px solid #555;
            padding-bottom: 0.35rem;
        }

        .tooltip-row {
            display: flex;
            gap: 1.5rem;
            padding: 0.3rem 0;
            align-items: center;
        }

        .tooltip-row .stat {
            color: #ccc;
        }

        .tooltip-row .value {
            margin-left: auto;
            color: #aaa;
        }

        .tooltip-row .pts {
            min-width: 45px;
            text-align: right;
            font-weight: 600;
        }

        .tooltip-row.total {
            margin-top: 0.5rem;
            border-top: 1px solid #555;
            padding-top: 0.5rem;
            font-weight: 700;
        }

        .tooltip-row.total .stat {
            color: white;
        }

        /* Mobile bottom sheet for player details */
        .player-sheet {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: var(--gray-800);
            border-radius: 20px 20px 0 0;
            padding: 1.5rem;
            z-index: 2501;
            transform: translateY(100%);
            transition: transform 0.3s ease;
            box-shadow: 0 -4px 20px rgba(0,0,0,0.4);
            max-height: 50vh;
            overflow-y: auto;
        }

        .player-sheet.visible {
            transform: translateY(0);
        }

        .player-sheet-header {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .player-sheet-badge {
            width: 50px;
            height: 50px;
            position: relative;
        }

        .player-sheet-badge img {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        .player-sheet-info h3 {
            font-size: 1.1rem;
            color: #fff;
            margin: 0;
        }

        .player-sheet-info p {
            font-size: 0.85rem;
            color: rgba(255, 255, 255, 0.7);
            margin: 0;
        }

        .player-sheet-points {
            font-size: 2rem;
            font-weight: 800;
            color: var(--accent);
            margin-left: auto;
        }

        .points-breakdown {
            background: var(--gray-900);
            border-radius: 12px;
            overflow: hidden;
        }

        .breakdown-header {
            display: grid;
            grid-template-columns: 1fr 60px 70px;
            padding: 0.75rem 1rem;
            background: rgba(255, 255, 255, 0.1);
            font-size: 0.75rem;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.6);
            text-transform: uppercase;
        }

        .breakdown-row {
            display: grid;
            grid-template-columns: 1fr 60px 70px;
            padding: 0.6rem 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 0.9rem;
        }

        .breakdown-row:last-child {
            border-bottom: none;
        }

        .breakdown-stat {
            color: rgba(255, 255, 255, 0.9);
        }

        .breakdown-value {
            text-align: center;
            color: rgba(255, 255, 255, 0.6);
        }

        .breakdown-pts {
            text-align: right;
            font-weight: 600;
            color: #27ae60;
        }

        .breakdown-pts.negative {
            color: #e74c3c;
        }

        .breakdown-total {
            display: grid;
            grid-template-columns: 1fr 60px 70px;
            padding: 0.75rem 1rem;
            background: var(--primary);
            color: white;
            font-weight: 700;
        }

        .breakdown-total span:last-child {
            text-align: right;
        }

        .sheet-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.5);
            z-index: 2500;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s;
        }

        .sheet-overlay.visible {
            opacity: 1;
            visibility: visible;
        }

        /* Auto-subs indicator */
        .auto-subs-bar {
            background: rgba(255, 193, 7, 0.15);
            border-bottom: 1px solid rgba(255, 193, 7, 0.3);
            padding: 0.5rem 1rem;
            font-size: 0.8rem;
            color: var(--warning);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .auto-subs-bar svg {
            width: 16px;
            height: 16px;
        }

        /* GW Navigation - positioned at top of header */
        .gw-nav {
            position: absolute;
            top: 0.5rem;
            left: 1.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .gw-nav-btn {
            background: rgba(255, 255, 255, 0.15);
            border: none;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: rgba(255, 255, 255, 0.8);
            transition: background 0.2s, opacity 0.2s, transform 0.15s;
        }

        .gw-nav-btn svg {
            width: 18px;
            height: 18px;
            stroke-width: 2.5;
        }

        .gw-nav-btn:hover:not(:disabled) {
            background: var(--accent);
            color: var(--primary);
            transform: scale(1.1);
        }

        .gw-nav-btn:active:not(:disabled) {
            transform: scale(0.95);
        }

        .gw-nav-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .gw-label {
            font-size: 0.9rem;
            font-weight: 700;
            color: rgba(255, 255, 255, 0.8);
            min-width: 55px;
            text-align: center;
        }

        /* Tinkering Bar */
        .tinkering-bar {
            background: var(--gray-800);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            cursor: pointer;
            transition: background 0.2s;
        }

        .tinkering-bar:hover {
            background: var(--gray-700);
        }

        .tinkering-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.75rem 1rem;
        }

        .tinkering-title {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.85rem;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.8);
        }

        .tinkering-title svg {
            width: 16px;
            height: 16px;
            color: rgba(255, 255, 255, 0.5);
        }

        .tinkering-impact {
            font-size: 1rem;
            font-weight: 700;
        }

        .tinkering-impact.positive {
            color: #27ae60;
        }

        .tinkering-impact.negative {
            color: #e74c3c;
        }

        .tinkering-impact.neutral {
            color: rgba(255, 255, 255, 0.6);
        }

        .tinkering-toggle {
            font-size: 0.75rem;
            color: rgba(255, 255, 255, 0.5);
            transition: transform 0.2s;
        }

        .tinkering-bar.expanded .tinkering-toggle {
            transform: rotate(180deg);
        }

        .tinkering-details {
            display: none;
            padding: 0 1rem 1rem;
            font-size: 0.85rem;
        }

        .tinkering-bar.expanded .tinkering-details {
            display: block;
        }

        .tinkering-summary {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            padding: 0.75rem;
            margin-bottom: 0.75rem;
            border-left: 4px solid rgba(255, 255, 255, 0.2);
        }

        .tinkering-row {
            display: flex;
            justify-content: space-between;
            padding: 0.35rem 0;
            color: rgba(255, 255, 255, 0.7);
            font-size: 0.85rem;
        }

        .tinkering-row.total {
            border-top: 2px solid rgba(255, 255, 255, 0.1);
            margin-top: 0.5rem;
            padding-top: 0.5rem;
            font-weight: 700;
            color: #fff;
            background: rgba(255, 255, 255, 0.05);
            margin: 0.5rem -0.75rem -0.75rem;
            padding: 0.75rem;
            border-radius: 0 0 4px 4px;
        }

        .tinkering-row.total .tinkering-impact {
            font-size: 1rem;
        }

        .tinkering-section {
            margin-top: 1rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            padding: 0.75rem;
        }

        .tinkering-section.positive-section {
            border-left: 4px solid #27ae60;
        }

        .tinkering-section.negative-section {
            border-left: 4px solid #e74c3c;
        }

        .tinkering-section.neutral-section {
            border-left: 4px solid #3498db;
        }

        .tinkering-section-total {
            display: flex;
            justify-content: space-between;
            margin-top: 0.5rem;
            padding-top: 0.5rem;
            border-top: 1px dashed rgba(255, 255, 255, 0.2);
            font-weight: 600;
            font-size: 0.8rem;
        }

        .tinkering-section-title {
            font-size: 0.75rem;
            font-weight: 700;
            text-transform: uppercase;
            color: rgba(255, 255, 255, 0.6);
            margin-bottom: 0.4rem;
            display: flex;
            align-items: center;
            gap: 0.4rem;
        }

        .tinkering-section-title.positive {
            color: #27ae60;
        }

        .tinkering-section-title.negative {
            color: #e74c3c;
        }

        .tinkering-item {
            display: flex;
            justify-content: space-between;
            padding: 0.2rem 0;
            color: rgba(255, 255, 255, 0.7);
        }

        .tinkering-item .points {
            font-weight: 600;
        }

        .tinkering-item .points.positive {
            color: #27ae60;
        }

        .tinkering-item .points.negative {
            color: #e74c3c;
        }

        .tinkering-badge {
            display: inline-block;
            padding: 0.15rem 0.4rem;
            border-radius: 3px;
            font-size: 0.65rem;
            font-weight: 700;
            margin-left: 0.5rem;
        }

        .tinkering-badge.freehit {
            background: #3498db;
            color: white;
        }

        .tinkering-badge.wildcard {
            background: #9b59b6;
            color: white;
        }

        .tinkering-badge.tc {
            background: #27ae60;
            color: white;
        }

        .tinkering-badge.bboost {
            background: #e67e22;
            color: white;
        }

        .tinkering-unavailable {
            padding: 0.75rem 1rem;
            color: rgba(255, 255, 255, 0.5);
            font-size: 0.85rem;
            text-align: center;
        }

        /* Events Ticker */
        .ticker-container {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 8px;
            margin-bottom: 1.5rem;
            overflow: hidden;
            position: relative;
        }

        .ticker-header {
            display: flex;
            flex-direction: column;
            padding: 0.5rem 1rem;
            background: rgba(255, 255, 255, 0.05);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            gap: 0.25rem;
        }

        .ticker-header-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .ticker-header .last-updated {
            font-size: 0.7rem;
            color: rgba(255, 255, 255, 0.5);
        }

        .ticker-header .live-indicator {
            padding: 0.2rem 0.5rem;
            font-size: 0.7rem;
        }

        .ticker-title {
            font-size: 0.75rem;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.7);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .ticker-title.live {
            color: var(--danger);
        }

        .next-kickoff {
            font-size: 0.7rem;
            color: rgba(255, 255, 255, 0.5);
        }

        .ticker-track {
            overflow-x: auto;
            white-space: nowrap;
            padding: 0.75rem 1rem;
            scrollbar-width: thin;
            scrollbar-color: rgba(255,255,255,0.3) transparent;
        }

        .ticker-track::-webkit-scrollbar {
            height: 4px;
        }

        .ticker-track::-webkit-scrollbar-thumb {
            background: rgba(255,255,255,0.3);
            border-radius: 2px;
        }

        .ticker-events {
            display: inline-flex;
            gap: 1rem;
        }

        .ticker-event {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            background: rgba(255, 255, 255, 0.08);
            padding: 0.5rem 0.9rem;
            border-radius: 20px;
            font-size: 0.85rem;
            white-space: nowrap;
            flex-shrink: 0;
        }

        .ticker-event .event-label {
            font-size: 0.7rem;
            color: rgba(255, 255, 255, 0.6);
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }

        .ticker-event .event-points {
            font-weight: 700;
            color: var(--accent);
        }

        .ticker-event .event-points.negative {
            color: var(--danger);
        }

        .ticker-event.transfer-hit {
            background: rgba(231, 76, 60, 0.25);
            border: 1px solid rgba(231, 76, 60, 0.5);
        }

        .ticker-event.goal {
            background: rgba(39, 174, 96, 0.2);
            border: 1px solid rgba(39, 174, 96, 0.4);
        }

        .ticker-event.assist {
            background: rgba(52, 152, 219, 0.2);
            border: 1px solid rgba(52, 152, 219, 0.4);
        }

        .ticker-event.yellow {
            background: rgba(241, 196, 15, 0.2);
            border: 1px solid rgba(241, 196, 15, 0.4);
        }

        .ticker-event.red {
            background: rgba(231, 76, 60, 0.2);
            border: 1px solid rgba(231, 76, 60, 0.4);
        }

        .ticker-event.own_goal {
            background: rgba(231, 76, 60, 0.2);
            border: 1px solid rgba(231, 76, 60, 0.4);
        }

        .ticker-event.pen_save {
            background: rgba(39, 174, 96, 0.2);
            border: 1px solid rgba(39, 174, 96, 0.4);
        }

        .ticker-event.pen_miss {
            background: rgba(231, 76, 60, 0.2);
            border: 1px solid rgba(231, 76, 60, 0.4);
        }

        .ticker-event.bonus {
            background: rgba(0, 255, 135, 0.2);
            border: 1px solid rgba(0, 255, 135, 0.4);
        }

        .ticker-event.saves {
            background: rgba(52, 152, 219, 0.2);
            border: 1px solid rgba(52, 152, 219, 0.4);
        }

        .ticker-event.clean_sheet {
            background: rgba(155, 89, 182, 0.2);
            border: 1px solid rgba(155, 89, 182, 0.4);
        }

        .ticker-event.goals_conceded {
            background: rgba(231, 76, 60, 0.2);
            border: 1px solid rgba(231, 76, 60, 0.4);
        }

        .ticker-event.defcon {
            background: rgba(46, 204, 113, 0.2);
            border: 1px solid rgba(46, 204, 113, 0.4);
        }

        /* Change events - more prominent styling */
        .ticker-event.change-event {
            border-width: 2px;
            animation: change-pulse 2s ease-out;
        }

        @keyframes change-pulse {
            0% { box-shadow: 0 0 0 0 rgba(255, 255, 255, 0.4); }
            70% { box-shadow: 0 0 0 6px rgba(255, 255, 255, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 255, 255, 0); }
        }

        .ticker-event.bonus_change {
            background: rgba(255, 215, 0, 0.25);
            border: 2px solid rgba(255, 215, 0, 0.6);
        }

        .ticker-event.cs_lost {
            background: rgba(231, 76, 60, 0.3);
            border: 2px solid rgba(231, 76, 60, 0.6);
        }

        .ticker-event.defcon_gained {
            background: rgba(46, 204, 113, 0.3);
            border: 2px solid rgba(46, 204, 113, 0.6);
        }

        .ticker-event .minute {
            font-size: 0.6rem;
            color: rgba(255, 255, 255, 0.5);
            margin-left: 0.25rem;
        }

        .ticker-event .impact-badge {
            display: inline-flex;
            align-items: center;
            padding: 0.1rem 0.3rem;
            border-radius: 3px;
            font-size: 0.65rem;
            font-weight: 700;
            margin-left: 0.3rem;
        }

        .ticker-event .impact-badge.positive {
            background: rgba(0, 255, 135, 0.3);
            color: var(--accent);
        }

        .ticker-event .impact-badge.negative {
            background: rgba(231, 76, 60, 0.3);
            color: var(--danger);
        }

        /* Bonus popup */
        .bonus-popup {
            position: fixed;
            background: var(--gray-900);
            border: 1px solid rgba(0, 255, 135, 0.4);
            border-radius: 8px;
            padding: 0.75rem;
            z-index: 3000;
            min-width: 180px;
            max-width: 250px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            display: none;
        }

        .bonus-popup.visible {
            display: block;
        }

        .bonus-popup-header {
            font-size: 0.7rem;
            font-weight: 700;
            color: var(--accent);
            margin-bottom: 0.5rem;
            padding-bottom: 0.35rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .bonus-player-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.2rem 0;
            font-size: 0.7rem;
        }

        .bonus-player-row .name {
            color: rgba(255, 255, 255, 0.9);
        }

        .bonus-player-row .bps {
            color: rgba(255, 255, 255, 0.5);
            font-size: 0.6rem;
            margin-left: 0.3rem;
        }

        .bonus-player-row .bonus-pts {
            font-weight: 700;
            color: var(--accent);
            min-width: 20px;
            text-align: right;
        }

        .bonus-player-row.near-miss {
            opacity: 0.5;
        }

        .bonus-player-row.near-miss .bonus-pts {
            color: rgba(255, 255, 255, 0.4);
        }

        .bonus-section-label {
            font-size: 0.6rem;
            color: rgba(255, 255, 255, 0.4);
            margin-top: 0.4rem;
            margin-bottom: 0.2rem;
        }

        .ticker-event {
            cursor: pointer;
            transition: transform 0.15s, box-shadow 0.15s;
        }

        .ticker-event:hover {
            transform: scale(1.05);
        }

        .ticker-event.selected {
            box-shadow: 0 0 0 2px var(--accent);
            transform: scale(1.05);
        }

        /* Event impact badge */
        .event-impact {
            display: inline-flex;
            align-items: center;
            margin-left: 0.4rem;
            padding: 0.15rem 0.35rem;
            border-radius: 4px;
            font-size: 0.7rem;
            font-weight: 700;
            animation: impact-pop 0.3s ease-out;
        }

        @keyframes impact-pop {
            0% { transform: scale(0.5); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }

        .event-impact.positive {
            background: rgba(0, 255, 135, 0.2);
            color: var(--accent);
        }

        .event-impact.negative {
            background: rgba(231, 76, 60, 0.2);
            color: var(--danger);
        }

        .event-impact .arrow {
            margin-right: 0.15rem;
            font-size: 0.6rem;
        }

        .ticker-event .icon {
            font-size: 0.85rem;
        }

        .ticker-event .player {
            font-weight: 600;
            color: rgba(255, 255, 255, 0.9);
        }

        .ticker-event .match {
            color: rgba(255, 255, 255, 0.5);
            font-size: 0.65rem;
        }

        .ticker-event .affected-count {
            color: rgba(255, 255, 255, 0.5);
            font-size: 0.65rem;
            font-weight: 500;
        }

        .ticker-empty {
            padding: 0.75rem 1rem;
            text-align: center;
            color: rgba(255, 255, 255, 0.5);
            font-size: 0.8rem;
        }

        /* Fixtures Mini Display */
        .fixtures-bar {
            display: flex;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            overflow-x: auto;
            background: rgba(255, 255, 255, 0.03);
            border-top: 1px solid rgba(255, 255, 255, 0.05);
        }

        .fixture-mini {
            display: flex;
            align-items: center;
            gap: 0.3rem;
            font-size: 0.65rem;
            color: rgba(255, 255, 255, 0.7);
            white-space: nowrap;
            padding: 0.25rem 0.5rem;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
        }

        .fixture-mini.live {
            background: rgba(231, 76, 60, 0.2);
            color: var(--danger);
        }

        .fixture-mini.finished {
            color: rgba(255, 255, 255, 0.4);
        }

        .fixture-mini .score {
            font-weight: 700;
        }

        .fixture-mini {
            cursor: pointer;
            transition: background 0.2s, transform 0.2s;
        }

        .fixture-mini:hover {
            background: rgba(0, 255, 135, 0.2);
            transform: scale(1.05);
        }

        /* Match Stats Modal */
        .match-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            align-items: flex-start;
            justify-content: center;
            z-index: 2000;
            padding: 1rem;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s;
            overflow-y: auto;
        }

        .match-modal-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .match-modal {
            background: var(--gray-900);
            border-radius: 16px;
            max-width: 800px;
            width: 100%;
            margin: 2rem auto;
            transform: scale(0.95);
            transition: transform 0.3s;
            border: 1px solid rgba(0, 255, 135, 0.2);
        }

        .match-modal-overlay.active .match-modal {
            transform: scale(1);
        }

        .match-modal-header {
            background: linear-gradient(135deg, var(--primary) 0%, var(--primary-light) 100%);
            padding: 1.25rem;
            border-radius: 16px 16px 0 0;
            text-align: center;
            position: relative;
        }

        .match-modal-header .close-btn {
            position: absolute;
            top: 0.75rem;
            right: 0.75rem;
            background: rgba(255,255,255,0.2);
            border: none;
            color: white;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 1.2rem;
        }

        .match-teams {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 1rem;
            font-size: 1.1rem;
            font-weight: 700;
            color: white;
        }

        .match-score {
            font-size: 1.5rem;
            background: rgba(0,0,0,0.3);
            padding: 0.25rem 0.75rem;
            border-radius: 8px;
        }

        .match-status {
            font-size: 0.75rem;
            color: rgba(255,255,255,0.7);
            margin-top: 0.5rem;
        }

        .match-modal-body {
            padding: 1rem;
            max-height: 60vh;
            overflow-y: auto;
        }

        /* Side-by-side teams container */
        .teams-side-by-side {
            display: flex;
            gap: 0;
            margin-bottom: 1.5rem;
        }

        .team-column {
            flex: 1;
            min-width: 0;
        }

        .team-column.home {
            border-right: 1px solid rgba(255, 255, 255, 0.1);
        }

        .team-column-header {
            font-size: 0.9rem;
            font-weight: 700;
            color: rgba(255,255,255,0.95);
            padding: 0.75rem 0.5rem;
            background: rgba(255, 255, 255, 0.05);
            text-align: center;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .team-column.home .team-column-header {
            border-radius: 8px 0 0 0;
        }

        .team-column.away .team-column-header {
            border-radius: 0 8px 0 0;
        }

        /* Player rows in side-by-side view */
        .player-row-sbs {
            display: flex;
            align-items: center;
            padding: 0.4rem 0.5rem;
            font-size: 0.8rem;
            border-bottom: 1px solid rgba(255,255,255,0.05);
            min-height: 40px;
            gap: 0.3rem;
        }

        .player-row-sbs:last-child {
            border-bottom: none;
        }

        .player-row-sbs .player-name-group {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            flex: 1;
            min-width: 0;
        }

        .player-row-sbs .player-name {
            color: rgba(255,255,255,0.9);
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .player-row-sbs .pos-indicator {
            color: rgba(255,255,255,0.45);
            font-size: 0.7rem;
            font-weight: 600;
            flex-shrink: 0;
        }

        .player-row-sbs .player-icons {
            display: flex;
            gap: 0.15rem;
            font-size: 0.7rem;
            flex-shrink: 0;
        }

        .player-row-sbs .player-pts {
            font-weight: 700;
            font-size: 0.9rem;
            min-width: 28px;
            text-align: center;
            color: white;
            flex-shrink: 0;
        }

        /* Home team: Name+icons left, score right */
        .team-column.home .player-row-sbs {
            flex-direction: row;
        }

        .team-column.home .player-row-sbs .player-name-group {
            justify-content: flex-start;
        }

        /* Away team: Score left, icons+name right */
        .team-column.away .player-row-sbs {
            flex-direction: row;
        }

        .team-column.away .player-row-sbs .player-name-group {
            justify-content: flex-end;
        }

        .player-pts.positive { color: var(--accent) !important; }
        .player-pts.negative { color: var(--danger) !important; }
        .player-pts.zero { color: rgba(255,255,255,0.4) !important; }

        /* Clickable player rows */
        .player-row-sbs.clickable {
            cursor: pointer;
            transition: background 0.15s ease;
        }
        .player-row-sbs.clickable:hover {
            background: rgba(255, 255, 255, 0.08);
        }

        /* Team divider between starters and subs */
        .team-divider {
            font-size: 0.65rem;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.4);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            padding: 0.5rem 0.5rem 0.3rem;
            border-top: 1px solid rgba(255, 255, 255, 0.15);
            margin-top: 0.25rem;
        }

        .player-icon {
            position: relative;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 20px;
            height: 20px;
            border-radius: 4px;
            font-size: 0.75rem;
        }

        .player-icon .icon-count {
            position: absolute;
            bottom: -2px;
            right: -2px;
            font-size: 0.5rem;
            font-weight: 700;
            color: white;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 50%;
            width: 12px;
            height: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            line-height: 1;
        }

        .player-icon.cs {
            background: rgba(155, 89, 182, 0.3);
        }

        .player-icon.goal {
            background: rgba(39, 174, 96, 0.3);
        }

        .player-icon.assist {
            background: rgba(52, 152, 219, 0.3);
        }

        .player-icon.yellow {
            background: rgba(241, 196, 15, 0.3);
        }

        .player-icon.red {
            background: rgba(231, 76, 60, 0.3);
        }

        /* Stats tables (DC, Saves, BP) - consistent with main table */
        .stats-tables-container {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            margin-top: 1rem;
        }

        .stats-table-section {
            background: rgba(255, 255, 255, 0.03);
            border-radius: 8px;
            overflow: hidden;
        }

        .stats-table-header {
            font-size: 0.9rem;
            font-weight: 700;
            color: var(--accent);
            padding: 0.75rem 0.5rem;
            background: rgba(255, 255, 255, 0.05);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.4rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .stats-table {
            display: flex;
            flex-direction: column;
        }

        .stats-table-row {
            display: flex;
            font-size: 0.8rem;
            min-height: 40px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .stats-table-row:last-child {
            border-bottom: none;
        }

        .stats-table-col {
            flex: 1;
            display: flex;
            align-items: center;
            padding: 0.4rem 0.5rem;
            gap: 0.3rem;
        }

        .stats-table-col.home {
            border-right: 1px solid rgba(255, 255, 255, 0.1);
        }

        .stats-player-name {
            color: rgba(255, 255, 255, 0.9);
            font-weight: 500;
            flex: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .stats-table-col.home .stats-player-name {
            text-align: left;
        }

        .stats-table-col.away .stats-player-name {
            text-align: right;
        }

        /* DC value styling */
        .dc-value, .saves-value, .bp-value {
            font-size: 0.8rem;
            font-weight: 700;
            color: rgba(255, 255, 255, 0.5);
            min-width: 28px;
            text-align: center;
            flex-shrink: 0;
        }

        .dc-value.achieved, .saves-value.achieved, .bp-value .bp-earned {
            color: var(--accent);
        }

        .bp-value {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            font-weight: 500;
        }

        .bp-earned {
            font-weight: 700;
        }

        /* Legacy styles kept for backwards compatibility */
        .team-section {
            margin-bottom: 1.5rem;
        }

        .team-section-header {
            font-size: 0.85rem;
            font-weight: 700;
            color: rgba(255,255,255,0.9);
            padding: 0.5rem 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            margin-bottom: 0.5rem;
        }

        .player-stat-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.4rem 0;
            font-size: 0.8rem;
            border-bottom: 1px solid rgba(255,255,255,0.05);
        }

        .player-stat-row:last-child {
            border-bottom: none;
        }

        .player-stat-info {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .player-stat-name {
            color: rgba(255,255,255,0.9);
        }

        .player-stat-pos {
            font-size: 0.65rem;
            color: rgba(255,255,255,0.4);
        }

        .player-stat-events {
            display: flex;
            gap: 0.25rem;
            font-size: 0.7rem;
        }

        .player-stat-pts {
            font-weight: 700;
            min-width: 30px;
            text-align: right;
        }

        .player-stat-pts.positive { color: var(--success); }
        .player-stat-pts.negative { color: var(--danger); }
        .player-stat-pts.zero { color: rgba(255,255,255,0.4); }

        .stat-badge {
            display: inline-block;
            padding: 0.1rem 0.25rem;
            border-radius: 3px;
            font-size: 0.6rem;
            font-weight: 600;
        }

        .stat-badge.goal { background: rgba(39, 174, 96, 0.3); color: #27ae60; }

        /* Show Matches Button */
        .show-matches-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: rgba(255, 255, 255, 0.8);
            padding: 0.4rem 0.8rem;
            border-radius: 20px;
            font-size: 0.75rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 0.4rem;
        }

        .show-matches-btn:hover {
            background: rgba(0, 255, 135, 0.2);
            border-color: var(--accent);
            color: var(--accent);
        }

        /* Fixtures List Modal */
        .fixtures-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            align-items: flex-start;
            justify-content: center;
            z-index: 2000;
            padding: 1rem;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s;
            overflow-y: auto;
        }

        .fixtures-modal-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .fixtures-modal {
            background: var(--gray-900);
            border-radius: 16px;
            max-width: 500px;
            width: 100%;
            margin: 2rem auto;
            transform: scale(0.95);
            transition: transform 0.3s;
            border: 1px solid rgba(0, 255, 135, 0.2);
        }

        .fixtures-modal-overlay.active .fixtures-modal {
            transform: scale(1);
        }

        .fixtures-modal-header {
            background: linear-gradient(135deg, var(--primary) 0%, var(--primary-light) 100%);
            padding: 1rem 1.25rem;
            border-radius: 16px 16px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .fixtures-modal-header h3 {
            margin: 0;
            color: white;
            font-size: 1.1rem;
            font-weight: 700;
        }

        .fixtures-modal-header .close-btn {
            background: rgba(255,255,255,0.2);
            border: none;
            color: white;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 1.2rem;
        }

        .fixtures-modal-body {
            padding: 1rem;
            max-height: 70vh;
            overflow-y: auto;
        }

        .fixture-item {
            display: flex;
            align-items: center;
            padding: 0.75rem;
            border-radius: 8px;
            margin-bottom: 0.5rem;
            background: rgba(255, 255, 255, 0.05);
            cursor: pointer;
            transition: all 0.2s;
        }

        .fixture-item:hover {
            background: rgba(0, 255, 135, 0.1);
        }

        .fixture-item.live {
            border: 2px solid var(--warning);
            background: rgba(255, 193, 7, 0.1);
        }

        .fixture-item.finished {
            opacity: 0.7;
        }

        .fixture-team {
            flex: 1;
            font-size: 0.85rem;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.9);
        }

        .fixture-team.home {
            text-align: right;
            padding-right: 0.75rem;
        }

        .fixture-team.away {
            text-align: left;
            padding-left: 0.75rem;
        }

        .fixture-score {
            min-width: 60px;
            text-align: center;
            font-size: 1.1rem;
            font-weight: 700;
            color: white;
            background: rgba(0, 0, 0, 0.3);
            padding: 0.25rem 0.5rem;
            border-radius: 6px;
        }

        .fixture-kickoff {
            min-width: 60px;
            text-align: center;
            font-size: 0.75rem;
            color: rgba(255, 255, 255, 0.6);
        }

        .fixture-status {
            font-size: 0.65rem;
            padding: 0.15rem 0.4rem;
            border-radius: 4px;
            margin-left: 0.5rem;
        }

        .fixture-status.live {
            background: var(--warning);
            color: black;
            font-weight: 700;
        }

        .fixture-status.ft {
            background: rgba(255, 255, 255, 0.2);
            color: rgba(255, 255, 255, 0.7);
        }

        /* BPS Section in Match Modal */
        .bps-section {
            margin-top: 1.5rem;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            padding-top: 1rem;
        }

        .bps-section-header {
            font-size: 0.85rem;
            font-weight: 700;
            color: var(--accent);
            margin-bottom: 0.75rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .bps-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.4rem 0.5rem;
            border-radius: 4px;
            margin-bottom: 0.25rem;
        }

        .bps-row.bonus-3 {
            background: rgba(255, 215, 0, 0.2);
        }

        .bps-row.bonus-2 {
            background: rgba(192, 192, 192, 0.15);
        }

        .bps-row.bonus-1 {
            background: rgba(205, 127, 50, 0.15);
        }

        .bps-player {
            font-size: 0.8rem;
            color: rgba(255, 255, 255, 0.9);
        }

        .bps-value {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .bps-score {
            font-size: 0.75rem;
            color: rgba(255, 255, 255, 0.5);
        }

        .bps-bonus {
            font-size: 0.85rem;
            font-weight: 700;
            color: var(--accent);
            min-width: 24px;
            text-align: right;
        }
        .stat-badge.assist { background: rgba(52, 152, 219, 0.3); color: #3498db; }
        .stat-badge.cs { background: rgba(155, 89, 182, 0.3); color: #9b59b6; }
        .stat-badge.yellow { background: rgba(241, 196, 15, 0.3); color: #f1c40f; }
        .stat-badge.red { background: rgba(231, 76, 60, 0.3); color: #e74c3c; }
        .stat-badge.bonus { background: rgba(0, 255, 135, 0.3); color: var(--accent); }

        /* Mobile fullscreen for match and fixtures modals */
        @media (max-width: 768px) {
            .match-modal-overlay,
            .fixtures-modal-overlay {
                padding: 0;
            }
            .match-modal,
            .fixtures-modal {
                max-width: 100%;
                min-height: 100%;
                margin: 0;
                border-radius: 0;
                border: none;
                display: flex;
                flex-direction: column;
            }
            .match-modal-header,
            .fixtures-modal-header {
                border-radius: 0;
            }
            .match-modal-body,
            .fixtures-modal-body {
                flex: 1;
                max-height: none;
                overflow-y: auto;
            }

            /* Side-by-side still works on mobile but with tighter spacing */
            .teams-side-by-side {
                gap: 0;
            }

            .team-column-header {
                font-size: 0.8rem;
                padding: 0.5rem 0.25rem;
            }

            .player-row-sbs {
                padding: 0.35rem 0.25rem;
                min-height: 38px;
            }

            .player-row-sbs .player-name {
                font-size: 0.75rem;
            }

            .player-row-sbs .player-pts {
                font-size: 0.85rem;
                min-width: 28px;
            }

            .player-icon {
                width: 16px;
                height: 16px;
                font-size: 0.6rem;
            }

            /* Stats tables stack on very small screens */
            .stats-tables-container {
                grid-template-columns: 1fr;
                gap: 0.75rem;
            }

            .stats-table-row {
                font-size: 0.7rem;
            }
        }

        @media (max-width: 480px) {
            .team-column-header {
                font-size: 0.75rem;
            }

            .player-row-sbs .player-name {
                font-size: 0.7rem;
            }

            .player-row-sbs .player-pos {
                display: none;
            }
        }

        /* Highlight Feature */
        .highlight-toolbar {
            flex-shrink: 0;
            display: flex;
            justify-content: flex-end;
            padding: 0.4rem 0.5rem 0;
        }

        .highlight-btn {
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.15);
            color: rgba(255, 255, 255, 0.7);
            padding: 0.3rem 0.65rem;
            border-radius: 6px;
            font-size: 0.72rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 0.3rem;
            transition: all 0.2s;
        }

        .highlight-btn:hover {
            background: rgba(255, 255, 255, 0.12);
        }

        .highlight-btn.active {
            background: rgba(0, 255, 135, 0.12);
            border-color: rgba(0, 255, 135, 0.4);
            color: var(--accent);
        }

        .highlight-popup-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 999;
            display: none;
            align-items: flex-start;
            justify-content: center;
            padding-top: 100px;
        }

        .highlight-popup-overlay.active {
            display: flex;
        }

        .highlight-popup {
            background: var(--primary-light, #1a1a2e);
            border-radius: 12px;
            width: 300px;
            max-width: 90vw;
            border: 1px solid rgba(255, 255, 255, 0.15);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }

        .highlight-popup-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .highlight-popup-header h3 {
            margin: 0;
            font-size: 0.85rem;
            color: white;
            font-weight: 600;
        }

        .highlight-popup-close {
            background: none;
            border: none;
            color: rgba(255, 255, 255, 0.5);
            font-size: 1.3rem;
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }

        .highlight-popup-close:hover {
            color: white;
        }

        .highlight-popup-body {
            padding: 0.75rem 1rem 1rem;
        }

        .highlight-section {
            margin-bottom: 0.75rem;
        }

        .highlight-section:last-child {
            margin-bottom: 0;
        }

        .highlight-section-title {
            font-size: 0.7rem;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.5);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 0.4rem;
        }

        .highlight-select {
            width: 100%;
            padding: 0.45rem 0.5rem;
            border-radius: 6px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: rgba(0, 0, 0, 0.3);
            color: white;
            font-size: 0.78rem;
            appearance: auto;
        }

        .highlight-select option {
            background: #1a1a2e;
            color: white;
        }

        .highlight-modes {
            display: flex;
            gap: 0.25rem;
            margin-top: 0.4rem;
        }

        .highlight-mode-btn {
            flex: 1;
            padding: 0.35rem;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: rgba(0, 0, 0, 0.2);
            color: rgba(255, 255, 255, 0.6);
            border-radius: 4px;
            font-size: 0.7rem;
            cursor: pointer;
            text-align: center;
            transition: all 0.15s;
        }

        .highlight-mode-btn:hover {
            background: rgba(255, 255, 255, 0.08);
        }

        .highlight-mode-btn.active {
            background: rgba(0, 255, 135, 0.15);
            border-color: rgba(0, 255, 135, 0.4);
            color: var(--accent);
        }

        .highlight-divider {
            height: 1px;
            background: rgba(255, 255, 255, 0.1);
            margin: 0.75rem 0;
        }

        .highlight-clear-btn {
            width: 100%;
            padding: 0.4rem;
            border: 1px solid rgba(255, 255, 255, 0.12);
            background: rgba(255, 255, 255, 0.05);
            color: rgba(255, 255, 255, 0.5);
            border-radius: 6px;
            font-size: 0.72rem;
            cursor: pointer;
            margin-top: 0.75rem;
            transition: all 0.15s;
        }

        .highlight-clear-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.8);
        }

        /* Highlighted table rows */
        .table-container tbody tr.hl-match td {
            background: rgba(0, 255, 135, 0.07);
        }

        .table-container tbody tr.hl-dimmed {
            opacity: 0.35;
        }

        .table-container tbody tr.hl-dimmed:hover {
            opacity: 0.6;
        }

        /* Defense count badge */
        .def-count-badge {
            display: inline-block;
            background: rgba(155, 89, 182, 0.3);
            color: #bb86fc;
            font-size: 0.6rem;
            font-weight: 700;
            padding: 0.1rem 0.35rem;
            border-radius: 3px;
            line-height: 1.2;
        }

        /* View Toggle */
        .view-toggle {
            display: inline-flex;
            background: rgba(255, 255, 255, 0.08);
            border-radius: 8px;
            padding: 3px;
            gap: 2px;
            margin-bottom: 1rem;
        }
        .view-toggle-btn {
            background: none;
            border: none;
            color: rgba(255, 255, 255, 0.6);
            padding: 0.4rem 1rem;
            border-radius: 6px;
            font-size: 0.8rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }
        .view-toggle-btn.active {
            background: var(--accent);
            color: var(--primary);
        }
        .view-toggle-btn:hover:not(.active) {
            color: rgba(255, 255, 255, 0.9);
            background: rgba(255, 255, 255, 0.1);
        }

        /* Standings-specific styles */
        /* Row position-change animation: Bounce Forward & Settle */
        .table-container tbody tr {
            will-change: auto;
        }
        .table-container tbody tr.row-bounce {
            position: relative;
            z-index: 20;
            will-change: transform, box-shadow;
            animation: rowBounce var(--bounce-duration, 1600ms) cubic-bezier(0.68, -0.55, 0.265, 1.55) var(--bounce-delay, 0ms) both;
        }
        .table-container tbody tr.row-bounce td {
            background: rgba(0, 255, 135, 0.05) !important;
        }
        @keyframes rowBounce {
            0% {
                transform: scale(1) translateY(var(--move-y, 0px));
                box-shadow: none;
            }
            20% {
                transform: scale(1.04) translateY(var(--move-y, 0px));
                box-shadow: 0 12px 40px rgba(0, 0, 0, 0.4);
            }
            60% {
                transform: scale(1.04) translateY(0);
                box-shadow: 0 12px 40px rgba(0, 0, 0, 0.4);
            }
            80% {
                transform: scale(0.98) translateY(0);
                box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            }
            90% {
                transform: scale(1.02) translateY(0);
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            }
            100% {
                transform: scale(1) translateY(0);
                box-shadow: none;
            }
        }

        /* Subtle settle animation for rows displaced downward */
        .table-container tbody tr.row-settle {
            position: relative;
            z-index: 10;
            will-change: transform, opacity;
            animation: rowSettle var(--settle-duration, 600ms) ease-out var(--settle-delay, 0ms) both;
        }
        @keyframes rowSettle {
            0% {
                transform: translateY(var(--move-y, 0px));
                opacity: 0.6;
            }
            100% {
                transform: translateY(0);
                opacity: 1;
            }
        }

        /* Persistent glow highlight for climbers after bounce finishes */
        .table-container tbody tr.row-climber-highlight td {
            background: rgba(0, 255, 135, 0.10) !important;
            transition: background 2s ease-out;
        }
        .table-container tbody tr.row-climber-highlight.fade-highlight td {
            background: transparent !important;
        }
        .value-pill {
            background: rgba(0, 255, 135, 0.15);
            color: var(--accent);
        }

        /* Standings Profile Modal */
        .profile-modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            z-index: 1000;
            overflow-y: auto;
            padding: 1rem;
            box-sizing: border-box;
        }
        .profile-modal-overlay.active {
            display: flex;
            justify-content: center;
            align-items: flex-start;
        }
        .profile-modal-content {
            background: var(--gray-900);
            border-radius: 12px;
            max-width: 600px;
            width: 100%;
            margin: 2rem auto;
            position: relative;
            border: 1px solid rgba(0, 255, 135, 0.2);
        }
        .profile-modal-header {
            padding: 1.5rem;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
        }
        .profile-modal-header-info h2 {
            margin: 0;
            color: var(--white);
            font-size: 1.4rem;
        }
        .profile-modal-header-info .team-name {
            color: var(--gray-400);
            font-size: 0.9rem;
            margin-top: 0.25rem;
        }
        .profile-modal-close {
            background: none;
            border: none;
            color: var(--gray-400);
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }
        .profile-modal-close:hover { color: var(--white); }
        .profile-modal-body { padding: 1.5rem; }
        .profile-quick-stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1rem;
            margin-bottom: 1.5rem;
        }
        .profile-stat-box {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            text-align: center;
        }
        .profile-stat-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--accent);
        }
        .profile-stat-label {
            font-size: 0.75rem;
            color: var(--gray-400);
            margin-top: 0.25rem;
        }
        .profile-stat-sub {
            font-size: 0.65rem;
            color: var(--gray-500);
            margin-top: 0.1rem;
        }
        .profile-chart-section { margin-bottom: 1.5rem; }
        .profile-chart-section h3 {
            font-size: 0.9rem;
            color: var(--gray-400);
            margin-bottom: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .profile-chart-container {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            padding: 1rem;
            height: 200px;
        }
        .profile-stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1.5rem;
        }
        .profile-stats-column h3 {
            font-size: 0.9rem;
            color: var(--gray-400);
            margin-bottom: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .profile-stats-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        .profile-stats-list li {
            display: flex;
            justify-content: space-between;
            padding: 0.5rem 0;
            border-bottom: 1px solid rgba(255,255,255,0.05);
            font-size: 0.85rem;
        }
        .profile-stats-list li:last-child { border-bottom: none; }
        .profile-stats-list .label { color: var(--gray-400); }
        .profile-stats-list .value { color: var(--white); font-weight: 600; }
        .profile-stats-list .value.highlight { color: var(--accent); }
        .profile-stats-list .value.negative { color: var(--danger); }
        .profile-modal-loading {
            text-align: center;
            padding: 3rem;
            color: var(--gray-400);
        }
        .profile-modal-loading::after {
            content: '';
            display: block;
            width: 40px;
            height: 40px;
            margin: 1rem auto;
            border: 3px solid rgba(0, 255, 135, 0.3);
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        /* Standings clickable rows */
        .standings-view tbody tr {
            cursor: pointer;
            transition: background 0.2s;
        }
        .standings-view tbody tr:hover {
            background: rgba(0, 255, 135, 0.1);
        }

        @media (max-width: 768px) {
            .profile-modal-overlay { padding: 0; }
            .profile-modal-content {
                max-width: 100%;
                min-height: 100%;
                width: 100%;
                margin: 0;
                border-radius: 0;
                display: flex;
                flex-direction: column;
            }
            .profile-modal-header { border-radius: 0; flex-shrink: 0; }
            .profile-modal-body { flex: 1; overflow-y: auto; }
        }
        @media (max-width: 600px) {
            .profile-quick-stats {
                grid-template-columns: repeat(3, 1fr);
                gap: 0.5rem;
            }
            .profile-stat-box { padding: 0.75rem 0.5rem; }
            .profile-stat-value { font-size: 1.2rem; }
            .profile-stat-label { font-size: 0.65rem; }
            .profile-stats-grid {
                grid-template-columns: 1fr;
                gap: 1rem;
            }
        }
    </style>
</head>
<body>
    <nav class="navbar">
        <div class="navbar-inner">
            <a href="/" class="navbar-brand"><img src="/favicon.png" alt="">Barry's FPL Mini League</a>
            <button class="nav-toggle" onclick="this.classList.toggle('active');document.querySelector('.navbar-links').classList.toggle('active')">
                <span></span><span></span><span></span>
            </button>
            <div class="navbar-links">
                <a href="/">Home</a>
                <a href="/week" class="active">Scores</a>
                <a href="/h2h">Head to Head</a>
                <a href="/losers">Weekly Losers</a>
                <a href="/motm">Manager of the Month</a>
                <a href="/chips">Chips</a>
                <a href="/earnings">Earnings</a>
                <a href="/cup">Cup</a>
                <a href="/hall-of-fame">Hall of Fame</a>
                <a href="/set-and-forget">Set & Forget</a>
                <a href="/rules">Rules</a>
                <a href="/admin" class="mobile-only">Admin</a>
            </div>
        </div>
    </nav>

    <!-- API Status Banner -->
    <div class="api-status-banner" id="api-status-banner">
        <span class="banner-icon">âš ï¸</span>
        <span id="api-status-message">FPL API temporarily unavailable. Showing cached data.</span>
        <span class="banner-time" id="api-status-time"></span>
    </div>

    <!-- Next GW Banner -->
    <div class="next-gw-banner" id="next-gw-banner">
        <span id="next-gw-message"></span>
    </div>

    <div class="page-header">
        <h1 id="league-name">Loading...</h1>
        <div class="view-toggle" style="margin-top: 0.75rem;">
            <button class="view-toggle-btn active" id="toggle-gw" onclick="switchView('gw')">Gameweek</button>
            <button class="view-toggle-btn" id="toggle-season" onclick="switchView('season')">Season</button>
            <button class="view-toggle-btn" id="toggle-form" onclick="switchView('form')">Form</button>
        </div>
    </div>

    <main>
        <div id="content">
            <div class="loading">Loading data...</div>
        </div>
    </main>

    <!-- Events Ticker - pinned to bottom -->
    <div id="ticker-area"></div>

    <!-- Highlight Popup -->
    <div class="highlight-popup-overlay" id="highlight-popup-overlay" onclick="closeHighlightPopup(event)">
        <div class="highlight-popup" onclick="event.stopPropagation()">
            <div class="highlight-popup-header">
                <h3>Highlight Managers</h3>
                <button class="highlight-popup-close" onclick="closeHighlightPopup()">&times;</button>
            </div>
            <div class="highlight-popup-body">
                <div class="highlight-section">
                    <div class="highlight-section-title">Player</div>
                    <select class="highlight-select" id="hl-player-select" onchange="onHighlightPlayerChange()">
                        <option value="">Select player...</option>
                    </select>
                    <div class="highlight-modes" id="hl-player-modes" style="display:none">
                        <button class="highlight-mode-btn active" data-mode="own" onclick="setHighlightMode(this)">Owned</button>
                        <button class="highlight-mode-btn" data-mode="started" onclick="setHighlightMode(this)">Started</button>
                        <button class="highlight-mode-btn" data-mode="benched" onclick="setHighlightMode(this)">Benched</button>
                    </div>
                </div>
                <div class="highlight-divider"></div>
                <div class="highlight-section">
                    <div class="highlight-section-title">Club Defense (GK + DEF)</div>
                    <select class="highlight-select" id="hl-team-select" onchange="onHighlightTeamChange()">
                        <option value="">Select club...</option>
                    </select>
                </div>
                <button class="highlight-clear-btn" onclick="clearHighlight()">Clear Highlights</button>
            </div>
        </div>
    </div>

    <!-- Modal -->
    <div class="modal-overlay" id="modal-overlay" onclick="closeModal(event)">
        <div class="modal" onclick="event.stopPropagation()">
            <div class="modal-header">
                <div class="gw-nav">
                    <button class="gw-nav-btn" id="gw-prev" onclick="navigateGW(-1)" disabled>
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"><polyline points="15 18 9 12 15 6"></polyline></svg>
                    </button>
                    <span class="gw-label" id="gw-label">GW 1</span>
                    <button class="gw-nav-btn" id="gw-next" onclick="navigateGW(1)" disabled>
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"><polyline points="9 18 15 12 9 6"></polyline></svg>
                    </button>
                </div>
                <div class="modal-header-info">
                    <h2 id="modal-manager-name">Manager</h2>
                    <div class="team-name" id="modal-team-name"></div>
                </div>
                <div class="modal-points" id="modal-points">0</div>
                <button class="modal-close" onclick="closeModal()">&times;</button>
            </div>
            <div class="modal-body" id="modal-body">
            </div>
        </div>
    </div>

    <!-- Tooltip for desktop -->
    <div class="tooltip" id="tooltip"></div>

    <!-- Mobile player sheet -->
    <div class="sheet-overlay" id="sheet-overlay" onclick="closePlayerSheet()"></div>
    <div class="player-sheet" id="player-sheet"></div>

    <!-- Bonus Popup -->
    <div class="bonus-popup" id="bonus-popup"></div>

    <!-- Fixtures List Modal -->
    <div class="fixtures-modal-overlay" id="fixtures-modal-overlay" onclick="closeFixturesModal(event)">
        <div class="fixtures-modal" onclick="event.stopPropagation()">
            <div class="fixtures-modal-header">
                <h3 id="fixtures-modal-title">Gameweek Fixtures</h3>
                <button class="close-btn" onclick="closeFixturesModal()">&times;</button>
            </div>
            <div class="fixtures-modal-body" id="fixtures-modal-body">
            </div>
        </div>
    </div>

    <!-- Standings Profile Modal -->
    <div class="profile-modal-overlay" id="profileModal">
        <div class="profile-modal-content">
            <div class="profile-modal-header">
                <div class="profile-modal-header-info">
                    <h2 id="profileModalName">Loading...</h2>
                    <div class="team-name" id="profileModalTeam"></div>
                </div>
                <button class="profile-modal-close" onclick="closeProfileModal()">&times;</button>
            </div>
            <div class="profile-modal-body" id="profileModalBody">
                <div class="profile-modal-loading">Loading profile data...</div>
            </div>
        </div>
    </div>

    <!-- Match Stats Modal -->
    <div class="match-modal-overlay" id="match-modal-overlay" onclick="closeMatchModal(event)">
        <div class="match-modal" onclick="event.stopPropagation()">
            <div class="match-modal-header">
                <button class="close-btn" onclick="closeMatchModal()">&times;</button>
                <div class="match-teams" id="match-teams">Loading...</div>
                <div class="match-status" id="match-status"></div>
            </div>
            <div class="match-modal-body" id="match-modal-body">
                <div class="loading" style="text-align: center; padding: 2rem;">Loading match data...</div>
            </div>
        </div>
    </div>

    <script>
        // JS fallback for browsers that don't support 100svh (older Samsung Internet, etc.)
        // Sets --vh so CSS can use calc(var(--vh, 1vh) * 100) as a last resort.
        if (!CSS.supports('height', '100svh')) {
            function setVh() {
                const vh = (window.visualViewport ? window.visualViewport.height : window.innerHeight) * 0.01;
                document.documentElement.style.setProperty('--vh', vh + 'px');
                document.documentElement.style.height = 'calc(var(--vh) * 100)';
            }
            setVh();
            if (window.visualViewport) window.visualViewport.addEventListener('resize', setVh);
            window.addEventListener('resize', setVh);
        }

        let weekData = null;
        let currentPicksData = null;
        let currentTinkeringData = null;
        let currentModalGW = null;
        let currentModalEntryId = null;
        let currentMatchStatsData = null;
        let currentMatchFixtureId = null;
        const matchStatsCache = {}; // Client-side cache: fixtureId -> { data, fixture }
        let currentSort = { col: 'gwScore', asc: false };
        let selectedEventIdx = null; // Currently selected event for impact display
        let selectedChangeIdx = null; // Currently selected change event
        let selectedChronoIdx = null; // Currently selected chronological event
        let refreshInterval = null;
        let isMobile = window.innerWidth < 768;
        let currentPlayerSheetId = null; // Track which player sheet is open for refresh
        let currentPlayerSheetParent = null; // 'manager' or 'match' - which modal owns the player sheet

        // Standings/Season view state
        let currentView = 'gw'; // 'gw', 'season', or 'form'
        let standingsData = [];
        let standingsGW = 0;
        let standingsSort = { col: null, asc: true };
        let rankChart = null;

        // Form view state
        let formData = [];
        let formWeeks = 5;
        let formTotalCompleted = 0;
        let formSort = { col: null, asc: true };
        let formLoading = false;

        // Highlight state
        let highlightState = {
            type: null,      // 'player' or 'defense'
            playerId: null,
            playerMode: 'own', // 'own', 'started', 'benched'
            teamId: null
        };

        function toggleHighlightPopup() {
            const overlay = document.getElementById('highlight-popup-overlay');
            if (overlay.classList.contains('active')) {
                closeHighlightPopup();
            } else {
                populateHighlightDropdowns();
                overlay.classList.add('active');
            }
        }

        function closeHighlightPopup(event) {
            if (event && event.target !== event.currentTarget) return;
            document.getElementById('highlight-popup-overlay').classList.remove('active');
        }

        function populateHighlightDropdowns() {
            if (!weekData) return;

            const playerSelect = document.getElementById('hl-player-select');
            const teamSelect = document.getElementById('hl-team-select');

            // Only repopulate if the data has changed (check option count)
            const squadPlayers = weekData.squadPlayers || {};
            const playerIds = Object.keys(squadPlayers);

            if (playerSelect.options.length !== playerIds.length + 1) {
                // Sort players alphabetically by name
                const sorted = playerIds
                    .map(id => ({ id: parseInt(id), ...squadPlayers[id] }))
                    .sort((a, b) => a.name.localeCompare(b.name));

                const currentVal = playerSelect.value;
                playerSelect.innerHTML = '<option value="">Select player...</option>';
                sorted.forEach(p => {
                    const pos = ['', 'GKP', 'DEF', 'MID', 'FWD'][p.positionId] || '';
                    const opt = document.createElement('option');
                    opt.value = p.id;
                    opt.textContent = `${p.name} (${pos})`;
                    playerSelect.appendChild(opt);
                });
                if (currentVal) playerSelect.value = currentVal;
            }

            const teams = weekData.plTeams || [];
            if (teamSelect.options.length !== teams.length + 1) {
                const currentVal = teamSelect.value;
                teamSelect.innerHTML = '<option value="">Select club...</option>';
                teams.forEach(t => {
                    const opt = document.createElement('option');
                    opt.value = t.id;
                    opt.textContent = t.name;
                    teamSelect.appendChild(opt);
                });
                if (currentVal) teamSelect.value = currentVal;
            }

            // Restore UI state
            const modesEl = document.getElementById('hl-player-modes');
            if (highlightState.type === 'player' && highlightState.playerId) {
                playerSelect.value = highlightState.playerId;
                modesEl.style.display = 'flex';
            }
            if (highlightState.type === 'defense' && highlightState.teamId) {
                teamSelect.value = highlightState.teamId;
            }
        }

        function onHighlightPlayerChange() {
            const playerId = parseInt(document.getElementById('hl-player-select').value);
            const modesEl = document.getElementById('hl-player-modes');

            if (playerId) {
                modesEl.style.display = 'flex';
                highlightState.type = 'player';
                highlightState.playerId = playerId;
                highlightState.teamId = null;
                // Reset team dropdown
                document.getElementById('hl-team-select').value = '';
                updateHighlightButton();
                renderTable();
            } else {
                modesEl.style.display = 'none';
                if (highlightState.type === 'player') {
                    highlightState.type = null;
                    highlightState.playerId = null;
                    updateHighlightButton();
                    renderTable();
                }
            }
        }

        function setHighlightMode(btn) {
            document.querySelectorAll('#hl-player-modes .highlight-mode-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            highlightState.playerMode = btn.dataset.mode;
            if (highlightState.type === 'player' && highlightState.playerId) {
                updateHighlightButton();
                renderTable();
            }
        }

        function onHighlightTeamChange() {
            const teamId = parseInt(document.getElementById('hl-team-select').value);

            if (teamId) {
                highlightState.type = 'defense';
                highlightState.teamId = teamId;
                highlightState.playerId = null;
                // Reset player dropdown and modes
                document.getElementById('hl-player-select').value = '';
                document.getElementById('hl-player-modes').style.display = 'none';
                updateHighlightButton();
                renderTable();
            } else {
                if (highlightState.type === 'defense') {
                    highlightState.type = null;
                    highlightState.teamId = null;
                    updateHighlightButton();
                    renderTable();
                }
            }
        }

        function clearHighlight() {
            highlightState.type = null;
            highlightState.playerId = null;
            highlightState.teamId = null;
            document.getElementById('hl-player-select').value = '';
            document.getElementById('hl-team-select').value = '';
            document.getElementById('hl-player-modes').style.display = 'none';
            updateHighlightButton();
            renderTable();
            closeHighlightPopup();
        }

        function updateHighlightButton() {
            const btn = document.getElementById('highlight-btn');
            if (!btn) return;
            const isActive = highlightState.type !== null;
            btn.classList.toggle('active', isActive);

            let label = 'Highlight';
            if (highlightState.type === 'player' && highlightState.playerId && weekData?.squadPlayers) {
                const p = weekData.squadPlayers[highlightState.playerId];
                if (p) {
                    const modeLabel = { own: 'Owned', started: 'Started', benched: 'Benched' }[highlightState.playerMode];
                    label = `${p.name} (${modeLabel})`;
                }
            } else if (highlightState.type === 'defense' && highlightState.teamId && weekData?.plTeams) {
                const t = weekData.plTeams.find(t => t.id === highlightState.teamId);
                if (t) label = `${t.shortName} Defense`;
            }
            // Keep the SVG icon, update text
            btn.innerHTML = `<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"></polygon></svg> ${label}`;
        }

        function getHighlightResult(manager) {
            if (!highlightState.type) return { match: false, defCount: 0 };

            if (highlightState.type === 'player') {
                const pid = highlightState.playerId;
                const mode = highlightState.playerMode;
                const inStarting = (manager.starting11 || []).includes(pid);
                const onBench = (manager.benchPlayerIds || []).includes(pid);
                const autoSubbedIn = (manager.autoSubsIn || []).includes(pid);
                const autoSubbedOut = (manager.autoSubsOut || []).includes(pid);
                const isBenchBoost = manager.activeChip === 'bboost';

                if (mode === 'own') {
                    return { match: inStarting || onBench, defCount: 0 };
                }

                if (mode === 'started') {
                    // In starting 11 and not auto-subbed out
                    const startedFromXI = inStarting && !autoSubbedOut;
                    // Auto-subbed in from bench
                    const subbedIn = autoSubbedIn;
                    // On bench with bench boost active
                    const benchBoostActive = onBench && isBenchBoost;
                    return { match: startedFromXI || subbedIn || benchBoostActive, defCount: 0 };
                }

                if (mode === 'benched') {
                    // On bench and no bench boost and not auto-subbed in
                    const benchedFromBench = onBench && !autoSubbedIn && !isBenchBoost;
                    // Auto-subbed out from starting 11
                    const benchedFromXI = inStarting && autoSubbedOut;
                    return { match: benchedFromBench || benchedFromXI, defCount: 0 };
                }
            }

            if (highlightState.type === 'defense') {
                const tId = highlightState.teamId;
                const squadPlayers = weekData?.squadPlayers || {};
                const allIds = [...(manager.starting11 || []), ...(manager.benchPlayerIds || [])];
                let count = 0;
                allIds.forEach(id => {
                    const p = squadPlayers[id];
                    if (p && p.teamId === tId && (p.positionId === 1 || p.positionId === 2)) {
                        count++;
                    }
                });
                return { match: count > 0, defCount: count };
            }

            return { match: false, defCount: 0 };
        }

        // â”€â”€ Row position-change animation helpers â”€â”€

        // Snapshot the current entry-id â†’ row-index map from a table container
        function captureRowPositions(container) {
            const map = {};
            if (!container) return map;
            const rows = container.querySelectorAll('tbody tr[data-entry-id]');
            rows.forEach((row, idx) => {
                map[row.dataset.entryId] = idx;
            });
            return map;
        }

        // After a re-render, animate rows whose position changed.
        // Climbers (moved up) get the prominent bounce; displaced rows settle subtly.
        function animateRowChanges(container, oldPositions) {
            if (!container || !oldPositions || Object.keys(oldPositions).length === 0) return;
            const rows = container.querySelectorAll('tbody tr[data-entry-id]');
            if (rows.length === 0) return;
            const rowHeight = rows[0].offsetHeight || 45;

            // First pass: identify climbers for stagger ordering
            const climbers = [];
            rows.forEach((row, newIdx) => {
                const entryId = row.dataset.entryId;
                const oldIdx = oldPositions[entryId];
                if (oldIdx === undefined || oldIdx === newIdx) return;
                const delta = oldIdx - newIdx;
                if (delta > 0) climbers.push({ row, newIdx, delta });
            });
            // Sort climbers by how many places they gained (biggest mover first)
            climbers.sort((a, b) => b.delta - a.delta);

            const climberStaggerMs = 200;
            // Displaced rows start after a short pause so climbers lead
            const settleDelay = 300;

            // Animate climbers with prominent bounce
            climbers.forEach((c, staggerIdx) => {
                const moveY = -c.delta * rowHeight;
                c.row.style.setProperty('--move-y', `${moveY}px`);
                c.row.style.setProperty('--bounce-duration', '1600ms');
                c.row.style.setProperty('--bounce-delay', `${staggerIdx * climberStaggerMs}ms`);
                c.row.classList.add('row-bounce');

                c.row.addEventListener('animationend', function handler() {
                    c.row.classList.remove('row-bounce');
                    c.row.style.removeProperty('--move-y');
                    c.row.style.removeProperty('--bounce-duration');
                    c.row.style.removeProperty('--bounce-delay');
                    // Add persistent highlight that fades out
                    c.row.classList.add('row-climber-highlight');
                    setTimeout(() => {
                        c.row.classList.add('fade-highlight');
                        setTimeout(() => {
                            c.row.classList.remove('row-climber-highlight', 'fade-highlight');
                        }, 2000);
                    }, 600);
                    c.row.removeEventListener('animationend', handler);
                }, { once: true });
            });

            // Animate displaced rows (moved down) with subtle settle
            const climberIds = new Set(climbers.map(c => c.row.dataset.entryId));
            rows.forEach((row, newIdx) => {
                const entryId = row.dataset.entryId;
                if (climberIds.has(entryId)) return;
                const oldIdx = oldPositions[entryId];
                if (oldIdx === undefined || oldIdx === newIdx) return;

                const delta = oldIdx - newIdx;
                const moveY = -delta * rowHeight;
                row.style.setProperty('--move-y', `${moveY}px`);
                row.style.setProperty('--settle-duration', '600ms');
                row.style.setProperty('--settle-delay', `${settleDelay}ms`);
                row.classList.add('row-settle');

                row.addEventListener('animationend', function handler() {
                    row.classList.remove('row-settle');
                    row.style.removeProperty('--move-y');
                    row.style.removeProperty('--settle-duration');
                    row.style.removeProperty('--settle-delay');
                    row.removeEventListener('animationend', handler);
                }, { once: true });
            });
        }

        // For standings: animate rows based on their movement data attribute.
        // Climbers get the prominent bounce; displaced rows settle subtly.
        function animateStandingsMovement(container) {
            if (!container) return;
            const allRows = container.querySelectorAll('tbody tr[data-entry-id]');
            if (allRows.length === 0) return;
            const rowHeight = allRows[0].offsetHeight || 45;

            // Separate climbers from fallers
            const climbers = [];
            const fallers = [];
            allRows.forEach((row) => {
                const movement = parseInt(row.dataset.movement);
                if (!movement || movement === 0) return;
                if (movement > 0) {
                    climbers.push({ row, movement });
                } else {
                    fallers.push({ row, movement });
                }
            });

            // Sort climbers by biggest mover first
            climbers.sort((a, b) => b.movement - a.movement);

            const climberStaggerMs = 200;
            const settleDelay = 300;

            // Animate climbers with prominent bounce
            climbers.forEach((c, staggerIdx) => {
                const moveY = -c.movement * rowHeight;
                c.row.style.setProperty('--move-y', `${moveY}px`);
                c.row.style.setProperty('--bounce-duration', '1600ms');
                c.row.style.setProperty('--bounce-delay', `${staggerIdx * climberStaggerMs}ms`);
                c.row.classList.add('row-bounce');

                c.row.addEventListener('animationend', function handler() {
                    c.row.classList.remove('row-bounce');
                    c.row.style.removeProperty('--move-y');
                    c.row.style.removeProperty('--bounce-duration');
                    c.row.style.removeProperty('--bounce-delay');
                    // Persistent highlight that fades
                    c.row.classList.add('row-climber-highlight');
                    setTimeout(() => {
                        c.row.classList.add('fade-highlight');
                        setTimeout(() => {
                            c.row.classList.remove('row-climber-highlight', 'fade-highlight');
                        }, 2000);
                    }, 600);
                    c.row.removeEventListener('animationend', handler);
                }, { once: true });
            });

            // Animate fallers with subtle settle
            fallers.forEach((f) => {
                const moveY = -f.movement * rowHeight;
                f.row.style.setProperty('--move-y', `${moveY}px`);
                f.row.style.setProperty('--settle-duration', '600ms');
                f.row.style.setProperty('--settle-delay', `${settleDelay}ms`);
                f.row.classList.add('row-settle');

                f.row.addEventListener('animationend', function handler() {
                    f.row.classList.remove('row-settle');
                    f.row.style.removeProperty('--move-y');
                    f.row.style.removeProperty('--settle-duration');
                    f.row.style.removeProperty('--settle-delay');
                    f.row.removeEventListener('animationend', handler);
                }, { once: true });
            });
        }
        let currentProfileEntryId = null;

        // Modal history management for proper back button behavior
        // Each modal open pushes state, back button closes current modal
        let modalHistoryInitialized = false;

        function initModalHistory() {
            if (modalHistoryInitialized) return;
            modalHistoryInitialized = true;

            // Set initial state (no modal open)
            window.history.replaceState({ modal: null }, '', window.location.pathname + window.location.search);

            // Listen for back/forward navigation
            window.addEventListener('popstate', handlePopState);
        }

        function handlePopState(event) {
            const state = event.state || { modal: null };

            const managerModalOpen = document.getElementById('modal-overlay').classList.contains('active');
            const fixturesModalOpen = document.getElementById('fixtures-modal-overlay').classList.contains('active');
            const matchModalOpen = document.getElementById('match-modal-overlay').classList.contains('active');
            const playerSheetOpen = document.getElementById('sheet-overlay').classList.contains('visible');

            // When closing a nested modal and the parent is already visible underneath,
            // just close the nested modal without tearing down and refetching the parent.

            // Player sheet â†’ manager modal (manager is visible underneath)
            if (playerSheetOpen && state.modal === 'manager' && managerModalOpen) {
                document.getElementById('sheet-overlay').classList.remove('visible');
                document.getElementById('player-sheet').classList.remove('visible');
                currentPlayerSheetId = null;
                currentPlayerSheetParent = null;
                return;
            }

            // Player sheet â†’ match modal (match is visible underneath)
            if (playerSheetOpen && state.modal === 'match' && matchModalOpen) {
                document.getElementById('sheet-overlay').classList.remove('visible');
                document.getElementById('player-sheet').classList.remove('visible');
                currentPlayerSheetId = null;
                currentPlayerSheetParent = null;
                return;
            }

            // Match modal â†’ fixtures modal (fixtures is already active underneath)
            if (matchModalOpen && state.modal === 'fixtures') {
                document.getElementById('match-modal-overlay').classList.remove('active');
                currentMatchStatsData = null;
                currentMatchFixtureId = null;
                // Fixtures overlay stayed active behind match - ensure it's visible as a safety net
                // (no-op if already active, handles deep-link edge cases)
                document.getElementById('fixtures-modal-overlay').classList.add('active');
                document.body.style.overflow = 'hidden';
                return;
            }

            // Full transition: close everything, then restore the target modal
            if (playerSheetOpen) {
                document.getElementById('sheet-overlay').classList.remove('visible');
                document.getElementById('player-sheet').classList.remove('visible');
                currentPlayerSheetId = null;
                currentPlayerSheetParent = null;
            }
            if (matchModalOpen) {
                document.getElementById('match-modal-overlay').classList.remove('active');
                currentMatchStatsData = null;
                currentMatchFixtureId = null;
            }
            if (fixturesModalOpen) {
                document.getElementById('fixtures-modal-overlay').classList.remove('active');
            }
            if (managerModalOpen) {
                document.getElementById('modal-overlay').classList.remove('active');
                currentPicksData = null;
                currentTinkeringData = null;
                currentModalGW = null;
                currentModalEntryId = null;
            }

            // Now restore the correct modal based on state
            if (state.modal === 'manager' && state.entryId) {
                openManagerModalFromHistory(state.entryId, state.gw);
            } else if (state.modal === 'fixtures') {
                openFixturesModalFromHistory();
            } else if (state.modal === 'match' && state.fixtureId) {
                openMatchModalFromHistory(state.fixtureId);
            } else if (state.modal === 'player-sheet') {
                // Restore parent modal first, then player sheet
                if (state.parentModal === 'manager' && state.parentEntryId) {
                    openManagerModalFromHistory(state.parentEntryId, state.parentGw).then(() => {
                        // Player sheet will need to be re-triggered by user
                        // as we don't have the full player data in history
                    });
                } else if (state.parentModal === 'match' && state.parentFixtureId) {
                    openMatchModalFromHistory(state.parentFixtureId);
                }
            } else {
                // No modal - ensure body scroll is restored
                document.body.style.overflow = '';
            }
        }

        function pushModalState(modalType, data = {}) {
            const state = { modal: modalType, ...data };
            const url = new URL(window.location);

            // Update URL params for deep linking
            if (modalType === 'manager') {
                url.searchParams.set('entry', data.entryId);
                url.searchParams.set('gw', data.gw);
            } else if (modalType === 'match') {
                url.searchParams.set('match', data.fixtureId);
            } else if (modalType === 'fixtures') {
                url.searchParams.set('view', 'fixtures');
            } else {
                // Clear modal-related params
                url.searchParams.delete('entry');
                url.searchParams.delete('gw');
                url.searchParams.delete('match');
                url.searchParams.delete('view');
            }

            window.history.pushState(state, '', url.toString());
        }

        // History-aware modal openers (don't push state, used by popstate)
        async function openManagerModalFromHistory(entryId, gw) {
            if (!weekData?.managers) return;
            const manager = weekData.managers.find(m => m.entryId === parseInt(entryId));
            if (!manager) return;

            currentModalEntryId = parseInt(entryId);
            currentModalGW = gw || weekData.currentGW;

            document.getElementById('modal-manager-name').textContent = manager.name;
            document.getElementById('modal-team-name').textContent = manager.team;
            document.getElementById('gw-label').textContent = `GW ${currentModalGW}`;
            document.getElementById('modal-body').innerHTML = '<div class="loading" style="padding: 2rem; color: #666;">Loading team...</div>';
            document.getElementById('modal-overlay').classList.add('active');
            document.body.style.overflow = 'hidden';

            await loadModalData(parseInt(entryId), currentModalGW);
        }

        function openFixturesModalFromHistory() {
            if (!weekData?.fixtures) return;

            const fixtures = weekData.fixtures;
            document.getElementById('fixtures-modal-title').textContent = `GW ${weekData.currentGW} Fixtures`;

            let html = fixtures.map(f => {
                let statusClass = '';
                let statusBadge = '';

                if (f.started && !f.finished) {
                    statusClass = 'live';
                    statusBadge = `<span class="fixture-status live">${f.minutes || 0}'</span>`;
                } else if (f.finished) {
                    statusClass = 'finished';
                    statusBadge = `<span class="fixture-status ft">FT</span>`;
                }

                const scoreOrTime = f.started
                    ? `<div class="fixture-score">${f.homeScore ?? 0} - ${f.awayScore ?? 0}</div>`
                    : `<div class="fixture-kickoff">${formatKickoffTime(f.kickoff)}</div>`;

                return `
                    <div class="fixture-item ${statusClass}" onclick="openMatchModal(${f.id});">
                        <span class="fixture-team home">${f.home}</span>
                        ${scoreOrTime}
                        <span class="fixture-team away">${f.away}</span>
                        ${statusBadge}
                    </div>
                `;
            }).join('');

            document.getElementById('fixtures-modal-body').innerHTML = html;
            document.getElementById('fixtures-modal-overlay').classList.add('active');
            document.body.style.overflow = 'hidden';
        }

        async function openMatchModalFromHistory(fixtureId) {
            const fid = parseInt(fixtureId);
            const fixture = weekData?.fixtures?.find(f => f.id === fid);
            if (!fixture) return;

            // Track current fixture for player sheet history
            currentMatchFixtureId = fid;

            const score = fixture.started
                ? `<span class="match-score">${fixture.homeScore ?? 0} - ${fixture.awayScore ?? 0}</span>`
                : 'vs';
            document.getElementById('match-teams').innerHTML = `${fixture.home} ${score} ${fixture.away}`;

            let status = '';
            if (fixture.finished) status = 'Full Time';
            else if (fixture.started) status = `${fixture.minutes || 0}'`;
            else status = formatKickoffTime(fixture.kickoff);
            document.getElementById('match-status').textContent = status;

            document.getElementById('match-modal-overlay').classList.add('active');
            document.body.style.overflow = 'hidden';

            // Fetch match stats (shows cached data immediately if available)
            await fetchMatchStats(fid, fixture);
        }

        const CHIP_NAMES = {
            'wildcard': 'WC',
            'freehit': 'FH',
            'bboost': 'BB',
            '3xc': 'TC'
        };

        // CSS class mapping (3xc -> tc for valid CSS selector)
        const CHIP_CLASSES = {
            'wildcard': 'wildcard',
            'freehit': 'freehit',
            'bboost': 'bboost',
            '3xc': 'tc'
        };

        const POSITION_LABELS = ['GKP', '1st Sub', '2nd Sub', '3rd Sub'];

        function sortTable(col) {
            if (currentSort.col === col) {
                currentSort.asc = !currentSort.asc;
            } else {
                currentSort.col = col;
                currentSort.asc = col === 'manager';
            }

            const sortKey = {
                'gwRank': m => m.gwRank,
                'manager': m => m.name.toLowerCase(),
                'captain': m => (m.captainName || '').toLowerCase(),
                'gwScore': m => m.gwScore,
                'playersLeft': m => m.playersLeft,
                'teamValue': m => parseFloat(m.teamValue),
                'benchPoints': m => m.benchPoints
            }[col];

            weekData.managers.sort((a, b) => {
                const aVal = sortKey(a), bVal = sortKey(b);
                if (typeof aVal === 'string') return currentSort.asc ? aVal.localeCompare(bVal) : bVal.localeCompare(aVal);
                return currentSort.asc ? aVal - bVal : bVal - aVal;
            });

            renderTable();
        }

        function sortClass(col) {
            if (currentSort.col !== col) return '';
            return currentSort.asc ? 'asc' : 'desc';
        }

        function renderTable(animate) {
            const container = document.querySelector('.table-container');
            const oldPositions = animate ? captureRowPositions(container) : null;

            let html = `
                <table>
                    <thead>
                        <tr>
                            <th style="width:6%" class="sortable ${sortClass('gwRank')}" onclick="sortTable('gwRank')">#</th>
                            <th style="width:30%" class="col-manager sortable ${sortClass('manager')}" onclick="sortTable('manager')">Manager</th>
                            <th style="width:30%" class="col-captain sortable ${sortClass('captain')}" onclick="sortTable('captain')">Captain</th>
                            <th style="width:17%" class="num sortable ${sortClass('gwScore')}" onclick="sortTable('gwScore')">Pts</th>
                            <th style="width:17%" class="num sortable ${sortClass('benchPoints')}" onclick="sortTable('benchPoints')">Bench</th>
                        </tr>
                    </thead>
                    <tbody>
            `;

            const hasHighlight = highlightState.type !== null;

            weekData.managers.forEach(m => {
                const rankClass = m.gwRank <= 3 ? `rank-${m.gwRank}` : '';

                // Highlight logic
                const hl = hasHighlight ? getHighlightResult(m) : { match: false, defCount: 0 };
                const hlClass = hasHighlight ? (hl.match ? 'hl-match' : 'hl-dimmed') : '';

                // Build info pills for under team name
                let pills = [];
                if (m.activeChip) {
                    pills.push(`<span class="info-pill chip-pill ${CHIP_CLASSES[m.activeChip]}">${CHIP_NAMES[m.activeChip]}</span>`);
                }
                if (m.playersLeft > 0) {
                    pills.push(`<span class="info-pill left-pill">${m.playersLeft} left</span>`);
                }
                if (hasHighlight && hl.match && hl.defCount > 0) {
                    pills.push(`<span class="info-pill def-count-badge">${hl.defCount} DEF</span>`);
                }
                const pillsHtml = pills.length > 0 ? `<div class="manager-pills">${pills.join('')}</div>` : '';

                // Event impact badge
                const impact = getEventImpactForManager(m);
                let impactHtml = '';
                if (impact !== null) {
                    const isPositive = impact >= 0;
                    const impactClass = isPositive ? 'positive' : 'negative';
                    const arrow = isPositive ? 'â–²' : 'â–¼';
                    impactHtml = `<span class="event-impact ${impactClass}"><span class="arrow">${arrow}</span>${Math.abs(impact)}</span>`;
                }

                html += `
                    <tr class="clickable ${hlClass}" data-entry-id="${m.entryId}" onclick="openManagerModal(${m.entryId})">
                        <td class="rank-cell ${rankClass}">${m.gwRank}</td>
                        <td class="col-manager">
                            <strong>${m.name}</strong>
                            <div class="team-name">${m.team}</div>
                            ${pillsHtml}
                        </td>
                        <td class="captain-cell">
                            ${m.captainName || '-'}
                            ${m.viceCaptainName ? `<div class="vice-captain">${m.viceCaptainName}</div>` : ''}
                        </td>
                        <td class="num"><span class="badge badge-success">${m.gwScore}</span>${impactHtml}</td>
                        <td class="num">${m.benchPoints}</td>
                    </tr>
                `;
            });

            html += '</tbody></table>';
            container.innerHTML = html;

            if (animate && oldPositions) {
                animateRowChanges(container, oldPositions);
            }
        }

        function formatTime(isoString) {
            const date = new Date(isoString);
            const now = new Date();
            const isToday = date.toDateString() === now.toDateString();
            const time = date.toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit' });
            if (isToday) return time;
            // Show date if not today so users know data is older
            const day = date.toLocaleDateString('en-GB', { day: 'numeric', month: 'short' });
            return `${day} ${time}`;
        }

        function formatKickoffTime(isoString) {
            if (!isoString) return '';
            const date = new Date(isoString);
            const now = new Date();
            const isToday = date.toDateString() === now.toDateString();
            const time = date.toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit' });
            if (isToday) return `Today ${time}`;
            const day = date.toLocaleDateString('en-GB', { weekday: 'short', day: 'numeric', month: 'short' });
            return `${day} ${time}`;
        }

        function buildTickerHtml(data) {
            if (!data) return '';

            const chronoEvents = data.chronologicalEvents || [];
            const liveEvents = data.liveEvents || [];
            const fixtures = data.fixtures || [];
            const nextKickoff = data.nextKickoff;
            const nextGWInfo = data.nextGWInfo;
            const hasLiveMatches = fixtures.some(f => f.started && !f.finished);

            // Extract transfer hits from liveEvents (they go at the beginning)
            const transferHits = liveEvents.filter(e => e.isTransferHit);

            // Event type to label mapping
            const EVENT_LABELS = {
                'goal': 'Goal',
                'assist': 'Assist',
                'yellow': 'Yellow',
                'red': 'Red',
                'own_goal': 'OG',
                'pen_save': 'Pen Save',
                'pen_miss': 'Pen Miss',
                'saves': 'Save Pt',
                'clean_sheet': 'CS',
                'team_clean_sheet': 'CS',
                'goals_conceded': 'GC',
                'team_goals_conceded': 'GC',
                'bonus_change': 'Bonus',
                'defcon': 'Defcon',
                'transfer_hit': 'Hit'
            };

            // Build transfer hit items (shown at beginning)
            const transferHitItems = transferHits.map((e, idx) => {
                const pointsDisplay = `${e.points}`;
                return `<div class="ticker-event transfer-hit" data-event-idx="${idx}">
                    <span class="icon">${e.icon}</span>
                    <span class="player">${e.player}</span>
                    <span class="event-label">Hit</span>
                    <span class="event-points negative">${pointsDisplay}</span>
                </div>`;
            }).join('');

            // Build chronological event items
            const chronoEventItems = chronoEvents.map((e, idx) => {
                const label = EVENT_LABELS[e.type] || '';
                const pointsClass = e.points >= 0 ? '' : 'negative';
                const pointsDisplay = e.points !== null ? (e.points >= 0 ? `+${e.points}` : `${e.points}`) : '';

                // Bonus change events
                if (e.type === 'bonus_change') {
                    const changes = e.changes || [];
                    const changesPreview = changes.slice(0, 2).map(c => {
                        const arrow = c.impact > 0 ? 'â–²' : (c.impact < 0 ? 'â–¼' : '');
                        return `${arrow}${c.player}`;
                    }).join(', ');

                    return `<div class="ticker-event bonus_change" onclick="showChronoBonusPopup(event, ${idx})" data-chrono-idx="${idx}">
                        <span class="icon">${e.icon}</span>
                        <span class="player">${changesPreview}</span>
                        <span class="event-label">${label}</span>
                        <span class="match">${e.match}</span>
                    </div>`;
                }

                // Team events (clean sheets and goals conceded grouped by team)
                if (e.type === 'team_clean_sheet' || e.type === 'team_goals_conceded') {
                    const players = e.affectedPlayers || [];
                    const playerCount = players.length;
                    const cssClass = e.type === 'team_clean_sheet' ? 'clean_sheet' : 'goals_conceded';

                    return `<div class="ticker-event ${cssClass}" onclick="showTeamEventPopup(event, ${idx})" data-chrono-idx="${idx}">
                        <span class="icon">${e.icon}</span>
                        <span class="player">${e.team}</span>
                        <span class="event-label">${label}</span>
                        <span class="event-points ${pointsClass}">${pointsDisplay}</span>
                        <span class="affected-count">(${playerCount})</span>
                        <span class="match">${e.match}</span>
                    </div>`;
                }

                // Regular events
                return `<div class="ticker-event ${e.type}" onclick="showChronoEventImpact(${idx})" data-chrono-idx="${idx}">
                    <span class="icon">${e.icon}</span>
                    <span class="player">${e.player}</span>
                    <span class="event-label">${label}</span>
                    <span class="event-points ${pointsClass}">${pointsDisplay}</span>
                    <span class="match">${e.match}</span>
                </div>`;
            }).join('');

            // Build events ticker - transfer hits first, then chronological events
            let eventsHtml = '';
            const allEventItems = transferHitItems + chronoEventItems;
            if (allEventItems.length > 0) {
                eventsHtml = `
                    <div class="ticker-track" id="ticker-track">
                        <div class="ticker-events">${allEventItems}</div>
                    </div>
                `;
            } else if (hasLiveMatches) {
                eventsHtml = `<div class="ticker-empty">Events from live matches will appear here</div>`;
            } else if (nextKickoff) {
                eventsHtml = `<div class="ticker-empty">Next match: ${formatKickoffTime(nextKickoff)}</div>`;
            } else if (nextGWInfo) {
                eventsHtml = `<div class="ticker-empty">Gameweek ${nextGWInfo.gameweek} kicks off ${formatKickoffTime(nextGWInfo.firstKickoff)}</div>`;
            } else {
                eventsHtml = `<div class="ticker-empty">No live matches</div>`;
            }

            const titleClass = hasLiveMatches ? 'live' : '';
            const titleText = hasLiveMatches ? 'Live Events' : 'Match Events';
            const clearBtnClass = (selectedEventIdx !== null || selectedChronoIdx !== null) ? 'visible' : '';

            // Build last updated text for ticker header
            const lastUpdatedText = data.lastUpdated ? `<span class="last-updated">Updated ${formatTime(data.lastUpdated)}</span>` : '';

            // Build bottom row: LIVE indicator, next kickoff, or next GW info
            let bottomRowHtml = '';
            if (hasLiveMatches) {
                bottomRowHtml = '<span class="live-indicator">LIVE</span>';
            } else if (nextKickoff) {
                bottomRowHtml = `<span class="next-kickoff">Next: ${formatKickoffTime(nextKickoff)}</span>`;
            } else if (nextGWInfo) {
                bottomRowHtml = `<span class="next-kickoff">GW${nextGWInfo.gameweek}: ${formatKickoffTime(nextGWInfo.firstKickoff)}</span>`;
            }

            return `
                <div class="ticker-container">
                    <div class="ticker-header">
                        <div class="ticker-header-row">
                            <span class="ticker-title ${titleClass}">${titleText}</span>
                            ${lastUpdatedText}
                        </div>
                        <div class="ticker-header-row">
                            ${bottomRowHtml}
                            <button class="show-matches-btn" onclick="event.stopPropagation(); openFixturesModal();">
                                <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/></svg>
                                Matches
                            </button>
                        </div>
                    </div>
                    ${eventsHtml}
                </div>
            `;
        }

        function showApiBanner(message, lastRefresh) {
            const banner = document.getElementById('api-status-banner');
            const msgEl = document.getElementById('api-status-message');
            const timeEl = document.getElementById('api-status-time');

            msgEl.textContent = message || 'FPL API temporarily unavailable. Showing cached data.';
            if (lastRefresh) {
                const date = new Date(lastRefresh);
                timeEl.textContent = `(Data from ${date.toLocaleString('en-GB', { day: 'numeric', month: 'short', hour: '2-digit', minute: '2-digit' })})`;
            }
            banner.classList.add('visible');
        }

        function hideApiBanner() {
            document.getElementById('api-status-banner').classList.remove('visible');
        }

        function updateNextGWBanner(nextGWInfo) {
            const banner = document.getElementById('next-gw-banner');
            const msgEl = document.getElementById('next-gw-message');
            if (!banner || !msgEl) return;

            if (nextGWInfo && nextGWInfo.firstKickoff) {
                const kickoff = new Date(nextGWInfo.firstKickoff);
                const now = new Date();
                const isToday = kickoff.toDateString() === now.toDateString();
                const tomorrow = new Date(now);
                tomorrow.setDate(tomorrow.getDate() + 1);
                const isTomorrow = kickoff.toDateString() === tomorrow.toDateString();

                const timeStr = kickoff.toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit' });
                let dayStr;
                if (isToday) {
                    dayStr = `today at ${timeStr}`;
                } else if (isTomorrow) {
                    dayStr = `tomorrow at ${timeStr}`;
                } else {
                    dayStr = kickoff.toLocaleDateString('en-GB', { weekday: 'short', day: 'numeric', month: 'short' }) + ` at ${timeStr}`;
                }

                msgEl.textContent = `Gameweek ${nextGWInfo.gameweek} kicks off ${dayStr}`;
                banner.classList.add('visible');
            } else {
                banner.classList.remove('visible');
            }
        }

        async function loadWeekData() {
            const isInitialLoad = !weekData;

            // On first load, immediately show cached data from localStorage
            // so users see content instantly instead of "Loading data..."
            if (isInitialLoad) {
                try {
                    const cached = localStorage.getItem('fpl-week-cache');
                    if (cached) {
                        const cachedData = JSON.parse(cached);
                        if (cachedData && cachedData.managers) {
                            weekData = cachedData;
                            document.getElementById('league-name').textContent = weekData.leagueName || 'Loading...';
                            document.getElementById('toggle-gw').textContent = `Gameweek ${weekData.currentGW}`;
                            renderMainContent();
                        }
                    }
                } catch(e) { /* ignore corrupt cache */ }
            }

            try {
                const res = await fetch('/api/week' + (window.getSeasonParam ? window.getSeasonParam() : ''));
                const data = await res.json();

                // Check if this is an error response with no data
                if (data.error && !data.managers) {
                    throw new Error(data.message || data.error);
                }

                weekData = data;

                // Cache for next visit so page loads instantly
                try { localStorage.setItem('fpl-week-cache', JSON.stringify(data)); } catch(e) { /* quota exceeded */ }

                // Check for API status flag (indicates cached data due to API outage)
                if (weekData._apiStatus) {
                    showApiBanner(weekData._apiStatus.message, weekData._apiStatus.lastRefresh);
                } else {
                    hideApiBanner();
                }

                // Show/hide incoming gameweek banner
                updateNextGWBanner(weekData.nextGWInfo);

                document.getElementById('league-name').textContent = weekData.leagueName;
                document.getElementById('toggle-gw').textContent = `Gameweek ${weekData.currentGW}`;

                // Clear event selection on refresh (indices may have changed)
                selectedEventIdx = null;
                selectedChangeIdx = null;
                selectedChronoIdx = null;

                renderMainContent();

                // Silently refresh any open modals with updated data
                refreshOpenModals();

                // Check for URL params to auto-open modal (e.g., from losers page)
                await handleUrlParams();

                if (weekData.isLive) {
                    if (!refreshInterval) {
                        refreshInterval = setInterval(loadWeekData, 60000);
                    }
                } else if (refreshInterval) {
                    clearInterval(refreshInterval);
                    refreshInterval = null;
                }

                // When there's a next GW incoming, schedule auto-refresh at its deadline
                // so the client transitions to the new GW data as soon as picks are available
                if (weekData.nextGWInfo && weekData.nextGWInfo.deadline) {
                    const deadlineTime = new Date(weekData.nextGWInfo.deadline);
                    const msUntilDeadline = deadlineTime.getTime() - Date.now();
                    if (msUntilDeadline > 0 && msUntilDeadline < 24 * 60 * 60 * 1000) {
                        // Refresh 30 seconds after deadline to let API update
                        if (window._nextGWRefreshTimer) clearTimeout(window._nextGWRefreshTimer);
                        window._nextGWRefreshTimer = setTimeout(() => {
                            console.log(`[Auto] GW${weekData.nextGWInfo.gameweek} deadline passed, refreshing...`);
                            loadWeekData();
                            // Start polling every 60s for the new GW (pre-match)
                            if (!refreshInterval) {
                                refreshInterval = setInterval(loadWeekData, 60000);
                            }
                        }, msUntilDeadline + 30000);
                    }
                }
            } catch (error) {
                // If we already have data (from cache or previous fetch), keep showing it
                if (weekData) {
                    console.warn('[Cache] Using existing data after fetch error:', error.message);
                    if (weekData.isLive && !refreshInterval) {
                        refreshInterval = setInterval(loadWeekData, 60000);
                    }
                    return;
                }

                // No data at all - show error UI
                let errorData = null;
                try {
                    const res = await fetch('/api/week' + (window.getSeasonParam ? window.getSeasonParam() : ''));
                    errorData = await res.json();
                } catch (e) { /* ignore */ }

                // Show error with helpful message
                const banner = document.getElementById('api-status-banner');
                banner.classList.add('visible', 'error');
                const errorMessage = errorData?.message || error.message || 'Unable to load data';
                document.getElementById('api-status-message').textContent = errorMessage;

                // Build availability message
                let availabilityHtml = '';
                if (errorData?.nextKickoff?.availableFrom) {
                    const availableTime = new Date(errorData.nextKickoff.availableFrom);
                    const kickoffTime = new Date(errorData.nextKickoff.kickoff);
                    const now = new Date();

                    if (availableTime > now) {
                        const timeStr = availableTime.toLocaleString('en-GB', {
                            weekday: 'short',
                            day: 'numeric',
                            month: 'short',
                            hour: '2-digit',
                            minute: '2-digit'
                        });
                        availabilityHtml = `
                            <div style="margin-top: 1.5rem; padding: 1rem; background: rgba(0, 255, 135, 0.1); border-radius: 8px; border: 1px solid rgba(0, 255, 135, 0.3);">
                                <div style="font-size: 0.8rem; color: rgba(255,255,255,0.6); margin-bottom: 0.25rem;">Live data available from</div>
                                <div style="font-size: 1.1rem; font-weight: 700; color: var(--accent);">${timeStr}</div>
                                <div style="font-size: 0.75rem; color: rgba(255,255,255,0.5); margin-top: 0.25rem;">~15 minutes before first kickoff</div>
                            </div>
                        `;
                    } else {
                        availabilityHtml = `
                            <div style="margin-top: 1rem; font-size: 0.85rem; color: rgba(255,255,255,0.6);">
                                Data should be available soon. Try refreshing in a few minutes.
                            </div>
                        `;
                    }
                }

                const errorDiv = document.createElement('div');
                errorDiv.className = 'loading';
                errorDiv.innerHTML = `
                    <div style="text-align: center; padding: 2rem;">
                        <div style="font-size: 2.5rem; margin-bottom: 1rem;">â³</div>
                        <div style="font-size: 1.1rem; font-weight: 600; margin-bottom: 0.5rem;">${errorMessage}</div>
                        <div style="font-size: 0.85rem; opacity: 0.7;">The FPL API is temporarily unavailable</div>
                        ${availabilityHtml}
                        <button onclick="loadWeekData()" style="margin-top: 1.5rem; padding: 0.6rem 1.5rem; background: var(--accent); color: var(--primary); border: none; border-radius: 8px; cursor: pointer; font-weight: 600; font-size: 0.9rem;">Retry</button>
                    </div>
                `;
                document.getElementById('content').innerHTML = '';
                document.getElementById('content').appendChild(errorDiv);
            }
        }

        // Renders the main content area (ticker + table) without destroying modal state.
        // On first call, creates the full DOM structure. On subsequent calls, updates in place.
        function renderMainContent() {
            if (!weekData) return;

            if (currentView === 'season') {
                renderSeasonView();
                loadStandingsData();
                return;
            }

            if (currentView === 'form') {
                renderFormView();
                return;
            }

            const tickerHtml = buildTickerHtml(weekData);
            // Update ticker in the pinned bottom area
            const tickerArea = document.getElementById('ticker-area');
            if (tickerArea) {
                tickerArea.innerHTML = tickerHtml;
            }

            const contentEl = document.getElementById('content');
            const existingTable = contentEl.querySelector('.table-container');

            if (!existingTable) {
                // First render - create toolbar + table container
                contentEl.innerHTML = `
                    <div class="highlight-toolbar">
                        <button class="highlight-btn" id="highlight-btn" onclick="toggleHighlightPopup()">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"></polygon></svg>
                            Highlight
                        </button>
                    </div>
                    <div class="table-container"></div>`;
                updateHighlightButton();
            }

            // Animate position changes when live data refreshes (existingTable = not first render)
            renderTable(!!existingTable);

            // Scroll ticker to show latest events (right side)
            const tickerTrack = document.getElementById('ticker-track');
            if (tickerTrack) {
                tickerTrack.scrollLeft = tickerTrack.scrollWidth;
            }
        }

        // Silently refreshes all currently open modals with updated data.
        // Preserves the user's navigation stack (matches -> match -> player).
        async function refreshOpenModals() {
            const managerModalOpen = document.getElementById('modal-overlay').classList.contains('active');
            const fixturesModalOpen = document.getElementById('fixtures-modal-overlay').classList.contains('active');
            const matchModalOpen = document.getElementById('match-modal-overlay').classList.contains('active');
            const playerSheetOpen = document.getElementById('sheet-overlay').classList.contains('visible');

            // Refresh fixtures modal content (just re-render from updated weekData)
            if (fixturesModalOpen && weekData?.fixtures) {
                refreshFixturesModalContent();
            }

            // Refresh manager modal (re-fetch picks and re-render pitch view)
            if (managerModalOpen && currentModalEntryId && currentModalGW) {
                const manager = weekData?.managers?.find(m => m.entryId === currentModalEntryId);
                if (manager) {
                    document.getElementById('modal-manager-name').textContent = manager.name;
                    document.getElementById('modal-team-name').textContent = manager.team;
                }

                try {
                    await loadModalData(currentModalEntryId, currentModalGW, true);
                } catch(e) { /* silent failure during background refresh */ }

                // Refresh player sheet if open from manager modal
                if (playerSheetOpen && currentPlayerSheetId && currentPlayerSheetParent === 'manager') {
                    refreshPlayerSheetContent();
                }
            }

            // Refresh match modal (re-fetch stats and re-render)
            if (matchModalOpen && currentMatchFixtureId) {
                const fixture = weekData?.fixtures?.find(f => f.id === currentMatchFixtureId);
                if (fixture) {
                    const score = fixture.started
                        ? `<span class="match-score">${fixture.homeScore ?? 0} - ${fixture.awayScore ?? 0}</span>`
                        : 'vs';
                    document.getElementById('match-teams').innerHTML = `${fixture.home} ${score} ${fixture.away}`;

                    let status = '';
                    if (fixture.finished) status = 'Full Time';
                    else if (fixture.started) status = `${fixture.minutes || 0}'`;
                    else status = formatKickoffTime(fixture.kickoff);
                    document.getElementById('match-status').textContent = status;
                }

                try {
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 30000);
                    const res = await fetch(`/api/fixture/${currentMatchFixtureId}/stats`, { signal: controller.signal });
                    clearTimeout(timeoutId);
                    const data = await res.json();
                    const fx = fixture || weekData?.fixtures?.find(f => f.id === currentMatchFixtureId);
                    if (data && !data.error) {
                        matchStatsCache[currentMatchFixtureId] = { data, fixture: fx };
                        renderMatchStats(data, fx);

                        // Refresh player sheet if open from match modal
                        if (playerSheetOpen && currentPlayerSheetId && currentPlayerSheetParent === 'match') {
                            refreshPlayerSheetContent();
                        }
                    }
                } catch(e) { /* silent failure during background refresh */ }
            }
        }

        // Re-renders the fixtures modal body from the current weekData
        function refreshFixturesModalContent() {
            if (!weekData?.fixtures) return;

            const fixtures = weekData.fixtures;
            document.getElementById('fixtures-modal-title').textContent = `GW ${weekData.currentGW} Fixtures`;

            let html = fixtures.map(f => {
                let statusClass = '';
                let statusBadge = '';
                if (f.started && !f.finished) {
                    statusClass = 'live';
                    statusBadge = `<span class="fixture-status live">${f.minutes || 0}'</span>`;
                } else if (f.finished) {
                    statusClass = 'finished';
                    statusBadge = `<span class="fixture-status ft">FT</span>`;
                }
                const scoreOrTime = f.started
                    ? `<div class="fixture-score">${f.homeScore ?? 0} - ${f.awayScore ?? 0}</div>`
                    : `<div class="fixture-kickoff">${formatKickoffTime(f.kickoff)}</div>`;
                return `
                    <div class="fixture-item ${statusClass}" onclick="openMatchModal(${f.id});">
                        <span class="fixture-team home">${f.home}</span>
                        ${scoreOrTime}
                        <span class="fixture-team away">${f.away}</span>
                        ${statusBadge}
                    </div>
                `;
            }).join('');

            document.getElementById('fixtures-modal-body').innerHTML = html;
        }

        // Re-renders the player sheet content without changing visibility or history
        function refreshPlayerSheetContent() {
            if (!currentPlayerSheetId) return;

            let player = null;
            if (currentPlayerSheetParent === 'manager' && currentPicksData) {
                player = currentPicksData.players?.find(p => p.id === currentPlayerSheetId);
            } else if (currentPlayerSheetParent === 'match' && currentMatchStatsData) {
                const allPlayers = [
                    ...(currentMatchStatsData.home?.starters || []),
                    ...(currentMatchStatsData.home?.subs || []),
                    ...(currentMatchStatsData.away?.starters || []),
                    ...(currentMatchStatsData.away?.subs || [])
                ];
                player = allPlayers.find(p => p.id === currentPlayerSheetId);
            }

            if (!player) return;

            const breakdown = player.pointsBreakdown || [];
            const basePoints = player.totalPoints || player.points || 0;
            const provisionalBonus = player.provisionalBonus || 0;

            let breakdownHtml = '';
            if (breakdown.length === 0) {
                breakdownHtml = '<div class="breakdown-row"><span>No points yet</span></div>';
            } else {
                breakdown.forEach(item => {
                    const ptsClass = item.points < 0 ? 'negative' : '';
                    const icon = item.icon || '';
                    breakdownHtml += `
                        <div class="breakdown-row">
                            <span class="breakdown-stat">${icon} ${item.stat}</span>
                            <span class="breakdown-value">${item.value}</span>
                            <span class="breakdown-pts ${ptsClass}">${item.points} pts</span>
                        </div>
                    `;
                });
            }

            if (provisionalBonus > 0) {
                breakdownHtml += `
                    <div class="breakdown-row" style="border-top: 1px dashed rgba(255,255,255,0.2);">
                        <span class="breakdown-stat" style="color: #00ff85;">â­ Provisional bonus</span>
                        <span class="breakdown-value" style="color: #00ff85;">[${player.bps} BPS]</span>
                        <span class="breakdown-pts" style="color: #00ff85;">+${provisionalBonus} pts</span>
                    </div>
                `;
            }

            const teamCode = player.teamCode || 1;
            const shirtSuffix = player.positionId === 1 ? '_1' : '';
            const shirtUrl = `https://fantasy.premierleague.com/dist/img/shirts/standard/shirt_${teamCode}${shirtSuffix}-110.webp`;

            const totalDisplay = provisionalBonus > 0
                ? `${basePoints}<span class="provisional-bonus" style="font-size: 0.5em;">+${provisionalBonus}</span>`
                : `${basePoints}`;
            const totalBreakdown = provisionalBonus > 0
                ? `${basePoints} + ${provisionalBonus} pts`
                : `${basePoints} pts`;

            document.getElementById('player-sheet').innerHTML = `
                <div class="player-sheet-header">
                    <div class="player-sheet-badge">
                        <img src="${shirtUrl}" alt="${player.teamName}">
                    </div>
                    <div class="player-sheet-info">
                        <h3>${player.fullName || player.name}</h3>
                        <p>${player.teamName} - ${player.position}</p>
                    </div>
                    <div class="player-sheet-points">${totalDisplay}</div>
                </div>
                <div class="points-breakdown">
                    <div class="breakdown-header">
                        <span>Statistic</span>
                        <span style="text-align:center">Value</span>
                        <span style="text-align:right">Points</span>
                    </div>
                    ${breakdownHtml}
                    <div class="breakdown-total">
                        <span>Total</span>
                        <span></span>
                        <span>${totalBreakdown}</span>
                    </div>
                </div>
            `;
        }

        async function openManagerModal(entryId) {
            const manager = weekData.managers.find(m => m.entryId === entryId);
            if (!manager) return;

            // Initialize modal state
            currentModalEntryId = entryId;
            currentModalGW = weekData.currentGW;

            document.getElementById('modal-manager-name').textContent = manager.name;
            document.getElementById('modal-team-name').textContent = manager.team;
            document.getElementById('modal-points').textContent = manager.gwScore;
            document.getElementById('gw-label').textContent = `GW ${currentModalGW}`;
            document.getElementById('modal-body').innerHTML = '<div class="loading" style="padding: 2rem; color: #666;">Loading team...</div>';
            document.getElementById('modal-overlay').classList.add('active');
            document.body.style.overflow = 'hidden';

            // Push to browser history for back button support
            pushModalState('manager', { entryId, gw: currentModalGW });

            await loadModalData(entryId, currentModalGW);
        }

        async function navigateGW(direction) {
            if (!currentModalEntryId) return;

            const newGW = currentModalGW + direction;
            if (newGW < 1 || (currentTinkeringData?.navigation && newGW > currentTinkeringData.navigation.maxGW)) {
                return;
            }

            currentModalGW = newGW;
            document.getElementById('gw-label').textContent = `GW ${currentModalGW}`;
            document.getElementById('modal-body').innerHTML = '<div class="loading" style="padding: 2rem; color: #666;">Loading team...</div>';

            // Update URL to reflect new GW (replace, not push - GW nav shouldn't create history entries)
            const url = new URL(window.location);
            url.searchParams.set('gw', currentModalGW);
            window.history.replaceState({ modal: 'manager', entryId: currentModalEntryId, gw: currentModalGW }, '', url.toString());

            await loadModalData(currentModalEntryId, currentModalGW);
        }

        async function loadModalData(entryId, gw, silent = false) {
            try {
                // Fetch picks and tinkering data in parallel
                const [picksRes, tinkeringRes] = await Promise.all([
                    fetch(`/api/manager/${entryId}/picks?gw=${gw}`),
                    fetch(`/api/manager/${entryId}/tinkering?gw=${gw}`)
                ]);

                if (!picksRes.ok) {
                    throw new Error(`Picks: HTTP ${picksRes.status}`);
                }
                if (!tinkeringRes.ok) {
                    throw new Error(`Tinkering: HTTP ${tinkeringRes.status}`);
                }

                currentPicksData = await picksRes.json();
                currentTinkeringData = await tinkeringRes.json();

                // Update points display (show bonus as +X if present)
                let pts = currentPicksData.basePoints ?? currentPicksData.calculatedPoints ?? currentPicksData.points;
                if (currentPicksData.activeChip === 'bboost') {
                    pts += currentPicksData.pointsOnBench || 0;
                }
                const bonus = currentPicksData.totalProvisionalBonus || 0;
                if (bonus > 0) {
                    document.getElementById('modal-points').innerHTML = `${pts}<span class="provisional-bonus" style="font-size: 0.5em; color: var(--success);">+${bonus}</span>`;
                } else {
                    document.getElementById('modal-points').textContent = currentPicksData.calculatedPoints || currentPicksData.points;
                }

                // Render pitch and tinkering bar
                renderPitchView(currentPicksData);

                // Update navigation buttons
                updateNavButtons();
            } catch (error) {
                // In silent mode (background refresh), don't show error UI
                if (silent) return;

                const errorDiv = document.createElement('div');
                errorDiv.className = 'loading';
                errorDiv.style.padding = '2rem';
                errorDiv.style.color = 'var(--danger)';
                errorDiv.textContent = 'Error: ' + error.message;
                document.getElementById('modal-body').innerHTML = '';
                document.getElementById('modal-body').appendChild(errorDiv);
            }
        }

        function updateNavButtons() {
            const prevBtn = document.getElementById('gw-prev');
            const nextBtn = document.getElementById('gw-next');

            if (currentTinkeringData?.navigation) {
                const nav = currentTinkeringData.navigation;
                prevBtn.disabled = currentModalGW <= 1;
                nextBtn.disabled = currentModalGW >= nav.maxGW;
            } else {
                prevBtn.disabled = currentModalGW <= 1;
                nextBtn.disabled = currentModalGW >= weekData.currentGW;
            }
        }

        function renderPlayerShirt(player) {
            const teamCode = player.teamCode || 1;
            // Use GK shirt for goalkeepers (positionId === 1)
            const shirtSuffix = player.positionId === 1 ? '_1' : '';
            const shirtUrl = `https://fantasy.premierleague.com/dist/img/shirts/standard/shirt_${teamCode}${shirtSuffix}-110.webp`;

            // Show TC badge (green) for Triple Captain, C badge (black) for normal captain
            const captainBadge = player.isCaptain
                ? (player.multiplier === 3 ? '<div class="tc-badge">TC</div>' : '<div class="captain-badge">C</div>')
                : '';

            return `
                <div class="player-shirt">
                    <img src="${shirtUrl}" alt="${player.teamName}" onerror="this.src='https://fantasy.premierleague.com/dist/img/shirts/standard/shirt_0-110.webp'">
                    ${captainBadge}
                    ${player.isViceCaptain ? '<div class="vice-badge">V</div>' : ''}
                </div>
            `;
        }

        function getPointsDisplay(player, isBench = false) {
            const basePoints = player.totalPoints || player.points || 0;

            // DGW: show both opponents if no game has started yet
            if (player.playStatus === 'not_started' && player.hasDoubleGameweek && player.fixtureDetails) {
                const opps = player.fixtureDetails.map(f => f.oppName).join(', ');
                return `<div class="player-points-pill not-played dgw-opponents">${opps}</div>`;
            }

            // If hasn't played yet, show opponent (for both starters and bench)
            if (player.playStatus === 'not_started') {
                return `<div class="player-points-pill not-played">${player.opponent || '-'}</div>`;
            }

            // DGW: benched/not played yet but has upcoming fixture - show next opponent
            if (player.playStatus === 'not_played_yet' && player.hasDoubleGameweek && player.fixtureDetails) {
                const nextFixture = player.fixtureDetails.find(f => !f.started) || player.fixtureDetails.find(f => !f.finished);
                if (nextFixture) {
                    return `<div class="player-points-pill not-played">${nextFixture.oppName}</div>`;
                }
            }

            if (player.playStatus === 'not_played_yet') {
                return `<div class="player-points-pill not-played">${player.opponent || '-'}</div>`;
            }

            // DGW: player has played in a completed fixture but has more fixtures to come
            // Show "pts | NEXT_OPP" split format
            if (player.hasDoubleGameweek && !player.allFixturesFinished && player.fixtureDetails) {
                const nextFixture = player.fixtureDetails.find(f => !f.started);
                if (nextFixture && player.playStatus !== 'playing') {
                    let effectiveMultiplier = player.subIn ? 1 : player.multiplier;
                    const pts = basePoints * effectiveMultiplier;
                    let bonusHtml = '';
                    if (player.provisionalBonus > 0) {
                        const bonusWithMultiplier = player.provisionalBonus * effectiveMultiplier;
                        bonusHtml = `<span class="provisional-bonus">+${bonusWithMultiplier}</span>`;
                    }
                    return `<div class="player-points-pill dgw-split">${pts}${bonusHtml} <span class="dgw-separator">|</span> <span class="dgw-next-opp">${nextFixture.oppName}</span></div>`;
                }
            }

            // Bench players (not subbed in) always show their actual points (no captain multiplier)
            if (isBench) {
                if (player.provisionalBonus > 0) {
                    return `<div class="player-points-pill" title="Base: ${basePoints}, Provisional bonus: +${player.provisionalBonus} (BPS: ${player.bps})">${basePoints}<span class="provisional-bonus">+${player.provisionalBonus}</span></div>`;
                }
                return `<div class="player-points-pill">${basePoints}</div>`;
            }

            // Calculate effective points
            // Subbed-in players get x1 (no captain bonus), original starters use their multiplier
            // multiplier is already 3 for TC captain, 2 for normal captain, 1 for others
            let effectiveMultiplier = player.subIn ? 1 : player.multiplier;
            const pts = basePoints * effectiveMultiplier;

            // Show provisional bonus as separate indicator (base score +bonus)
            // Bonus points DO get captain multiplier
            if (player.provisionalBonus > 0) {
                const bonusWithMultiplier = player.provisionalBonus * effectiveMultiplier;
                return `<div class="player-points-pill" title="Base: ${pts}, Provisional bonus: +${bonusWithMultiplier} (BPS: ${player.bps})">${pts}<span class="provisional-bonus">+${bonusWithMultiplier}</span></div>`;
            }

            return `<div class="player-points-pill">${pts}</div>`;
        }

        // Icon configuration for player events
        const EVENT_ICONS = {
            'goals_scored': { icon: 'âš½', showCount: true },
            'own_goals': { icon: 'âš½', showCount: true, style: 'filter: hue-rotate(320deg) saturate(1.5);' },
            'assists': { icon: 'ðŸ‘Ÿ', showCount: true },
            'clean_sheets': { icon: 'ðŸ›¡ï¸', showCount: false },
            'defensive_contribution': { icon: 'ðŸ”’', showCount: false },
            'yellow_cards': { icon: 'ðŸŸ¨', showCount: false },
            'red_cards': { icon: 'ðŸŸ¥', showCount: false },
            'penalties_saved': { icon: 'ðŸ§¤', showCount: false },
            'penalties_missed': { icon: 'âŒ', showCount: false },
            'saves': { icon: 'ðŸ§¤', showCount: false }
        };

        function buildEventIcons(pointsBreakdown) {
            if (!pointsBreakdown) return '';

            // Check if player has red card (replaces yellow)
            const hasRed = pointsBreakdown.some(p => p.identifier === 'red_cards');

            const icons = [];
            const priorityOrder = ['goals_scored', 'own_goals', 'assists', 'clean_sheets', 'defensive_contribution', 'red_cards', 'yellow_cards', 'penalties_saved', 'penalties_missed', 'saves'];

            priorityOrder.forEach(type => {
                if (type === 'yellow_cards' && hasRed) return;

                const breakdown = pointsBreakdown.find(p => p.identifier === type);
                if (!breakdown) return;

                const config = EVENT_ICONS[type];
                if (!config) return;

                const count = typeof breakdown.value === 'number' ? breakdown.value : 1;
                const showNum = config.showCount && count > 1;
                const style = config.style || '';

                icons.push(`<span title="${breakdown.stat}" style="${style}">${config.icon}${showNum ? count : ''}</span>`);
            });

            return icons.join('');
        }

        function renderPlayer(player, isBench = false) {
            const subClass = player.subOut ? 'subbed-out' : (player.subIn ? 'subbed-in' : '');
            const playingClass = player.playStatus === 'playing' ? 'playing' : '';
            // Don't fade DGW players who still have fixtures remaining
            const isFinished = (player.playStatus === 'played' || player.playStatus === 'benched');
            const finishedClass = isFinished && (!player.hasDoubleGameweek || player.allFixturesFinished) ? 'finished' : '';
            const eventsHtml = buildEventIcons(player.pointsBreakdown);

            return `
                <div class="player-card ${subClass} ${playingClass} ${finishedClass}"
                     data-player-id="${player.id}"
                     onmouseenter="showTooltip(event, ${player.id})"
                     onmouseleave="hideTooltip()"
                     onclick="handlePlayerClick(${player.id})">
                    ${renderPlayerShirt(player)}
                    <div class="player-name-box">
                        <span class="player-name">${player.name}</span>
                    </div>
                    ${getPointsDisplay(player, isBench)}
                    ${!isBench && eventsHtml ? `<div class="player-events">${eventsHtml}</div>` : ''}
                </div>
            `;
        }

        function renderPitchView(data) {
            // Separate starters and bench, account for auto-subs
            const effectiveStarters = data.players.filter(p => (!p.isBench && !p.subOut) || p.subIn);
            const effectiveBench = data.players.filter(p => (p.isBench && !p.subIn) || p.subOut);

            // Sort bench by original bench order, but GK always goes to GKP slot (first)
            effectiveBench.sort((a, b) => {
                if (a.positionId === 1 && b.positionId !== 1) return -1;
                if (a.positionId !== 1 && b.positionId === 1) return 1;
                const aOrder = a.isBench ? a.benchOrder : 99;
                const bOrder = b.isBench ? b.benchOrder : 99;
                return aOrder - bOrder;
            });

            // Group by position
            const gk = effectiveStarters.filter(p => p.positionId === 1);
            const def = effectiveStarters.filter(p => p.positionId === 2);
            const mid = effectiveStarters.filter(p => p.positionId === 3);
            const fwd = effectiveStarters.filter(p => p.positionId === 4);

            const chipText = data.activeChip ? ` - ${CHIP_NAMES[data.activeChip] || data.activeChip} Active` : '';

            // Auto-subs notification
            let autoSubsHtml = '';
            if (data.autoSubs && data.autoSubs.length > 0) {
                const subText = data.autoSubs.map(s => `${s.in.name} for ${s.out.name}`).join(', ');
                autoSubsHtml = `
                    <div class="auto-subs-bar">
                        <svg viewBox="0 0 24 24" fill="currentColor"><path d="M12 4V1L8 5l4 4V6c3.31 0 6 2.69 6 6 0 1.01-.25 1.97-.7 2.8l1.46 1.46C19.54 15.03 20 13.57 20 12c0-4.42-3.58-8-8-8zm0 14c-3.31 0-6-2.69-6-6 0-1.01.25-1.97.7-2.8L5.24 7.74C4.46 8.97 4 10.43 4 12c0 4.42 3.58 8 8 8v3l4-4-4-4v3z"/></svg>
                        Auto-sub: ${subText}
                    </div>
                `;
            }

            let html = `
                <div class="formation-bar">Formation: <strong>${data.formation}</strong>${chipText}</div>
                ${autoSubsHtml}
                <div class="pitch-container">
                    <div class="pitch-markings">
                        <div class="pitch-halfway"></div>
                        <div class="pitch-center"></div>
                        <div class="pitch-box-top"></div>
                        <div class="pitch-box-bottom"></div>
                    </div>
                    <div class="formation-row gk">${gk.map(p => renderPlayer(p)).join('')}</div>
                    <div class="formation-row">${def.map(p => renderPlayer(p)).join('')}</div>
                    <div class="formation-row">${mid.map(p => renderPlayer(p)).join('')}</div>
                    <div class="formation-row fwd">${fwd.map(p => renderPlayer(p)).join('')}</div>
                </div>
                <div class="bench-container">
                    <div class="bench-header">
                        <span class="bench-label">Substitutes</span>
                        <span class="bench-points">${data.pointsOnBench} pts</span>
                    </div>
                    <div class="bench-row">
                        ${effectiveBench.map((p, i) => `
                            <div class="bench-slot">
                                <div class="bench-position">${POSITION_LABELS[i] || ''}</div>
                                ${renderPlayer(p, true)}
                            </div>
                        `).join('')}
                    </div>
                </div>
                ${renderTinkeringBar()}
            `;

            document.getElementById('modal-body').innerHTML = html;
        }

        function renderTinkeringBar() {
            if (!currentTinkeringData) return '';

            // If tinkering not available (GW1 or error)
            if (!currentTinkeringData.available) {
                if (currentTinkeringData.reason === 'gw1') {
                    return `<div class="tinkering-unavailable">No tinkering data for GW1 (no previous team to compare)</div>`;
                }
                return '';
            }

            const { actualScore, hypotheticalScore, transferCost, netImpact, reason,
                    transfersIn, transfersOut, captainChange, lineupChanges, autoSubEffects, chipImpact } = currentTinkeringData;

            // Determine impact class
            let impactClass = 'neutral';
            if (netImpact > 0) impactClass = 'positive';
            else if (netImpact < 0) impactClass = 'negative';

            // Format impact display
            const impactDisplay = netImpact > 0 ? `+${netImpact}` : netImpact.toString();

            // Build chip badge if applicable
            let chipBadge = '';
            if (reason === 'freehit') chipBadge = '<span class="tinkering-badge freehit">FH</span>';
            else if (reason === 'wildcard') chipBadge = '<span class="tinkering-badge wildcard">WC</span>';
            else if (reason === '3xc') chipBadge = '<span class="tinkering-badge tc">TC</span>';
            else if (reason === 'bboost') chipBadge = '<span class="tinkering-badge bboost">BB</span>';

            // Build transfers in section with true impact
            let transfersInHtml = '';
            if (transfersIn && transfersIn.length > 0) {
                const totalImpact = transfersIn.reduce((sum, t) => sum + (t.impact || 0), 0);
                const impactClass = totalImpact > 0 ? 'positive' : (totalImpact < 0 ? 'negative' : 'neutral');
                const impactSign = totalImpact > 0 ? '+' : '';
                transfersInHtml = `
                    <div class="tinkering-section positive-section">
                        <div class="tinkering-section-title positive">Transfers In</div>
                        ${transfersIn.map(t => {
                            const ptsClass = (t.impact || 0) > 0 ? 'positive' : ((t.impact || 0) < 0 ? 'negative' : 'neutral');
                            const ptsSign = (t.impact || 0) > 0 ? '+' : '';
                            const captainLabel = t.captained ? (reason === '3xc' ? ' (TC)' : ' (C)') : '';
                            return `
                            <div class="tinkering-item">
                                <span>${t.player.name}${captainLabel}</span>
                                <span class="points ${ptsClass}">${ptsSign}${t.impact || 0} pts</span>
                            </div>
                        `}).join('')}
                        <div class="tinkering-section-total">
                            <span>Section Total</span>
                            <span class="points ${impactClass}">${impactSign}${totalImpact} pts</span>
                        </div>
                    </div>
                `;
            }

            // Build transfers out section with true impact
            let transfersOutHtml = '';
            if (transfersOut && transfersOut.length > 0) {
                const totalImpact = transfersOut.reduce((sum, t) => sum + (t.impact || 0), 0);
                const impactClass = totalImpact > 0 ? 'positive' : (totalImpact < 0 ? 'negative' : 'neutral');
                const impactSign = totalImpact > 0 ? '+' : '';
                transfersOutHtml = `
                    <div class="tinkering-section negative-section">
                        <div class="tinkering-section-title negative">Transfers Out</div>
                        ${transfersOut.map(t => {
                            // Show as negative since these are points you "lost"
                            const displayImpact = -(t.impact || 0);
                            const ptsClass = displayImpact > 0 ? 'positive' : (displayImpact < 0 ? 'negative' : 'neutral');
                            const ptsSign = displayImpact > 0 ? '+' : '';
                            return `
                            <div class="tinkering-item">
                                <span>${t.player.name}${t.wasCaptain ? ' (was C)' : ''}</span>
                                <span class="points ${ptsClass}">${ptsSign}${displayImpact} pts</span>
                            </div>
                        `}).join('')}
                        <div class="tinkering-section-total">
                            <span>Section Total</span>
                            <span class="points ${impactClass}">${-totalImpact > 0 ? '+' : ''}${-totalImpact} pts</span>
                        </div>
                    </div>
                `;
            }

            // Build captain change section
            let captainHtml = '';
            if (captainChange && captainChange.changed) {
                const capImpact = captainChange.impact;
                const capClass = capImpact > 0 ? 'positive' : (capImpact < 0 ? 'negative' : 'neutral');
                const sectionClass = capImpact > 0 ? 'positive-section' : (capImpact < 0 ? 'negative-section' : 'neutral-section');
                const capSign = capImpact > 0 ? '+' : '';
                captainHtml = `
                    <div class="tinkering-section ${sectionClass}">
                        <div class="tinkering-section-title ${capClass}">Captain Change</div>
                        <div class="tinkering-item">
                            <span>${captainChange.oldCaptain?.name} (${captainChange.oldCaptain?.points} pts) &rarr; ${captainChange.newCaptain?.name} (${captainChange.newCaptain?.points} pts)</span>
                        </div>
                        <div class="tinkering-section-total">
                            <span>Impact</span>
                            <span class="points ${capClass}">${capSign}${capImpact} pts</span>
                        </div>
                    </div>
                `;
            }

            // Build lineup changes section with true impact
            let lineupHtml = '';
            const hasLineupChanges = (lineupChanges?.movedToStarting?.length > 0) || (lineupChanges?.movedToBench?.length > 0);
            if (hasLineupChanges) {
                // Sum impacts (they already have the correct sign from server calculation)
                const startedImpact = lineupChanges.movedToStarting?.reduce((sum, p) => sum + (p.impact || 0), 0) || 0;
                const benchedImpact = lineupChanges.movedToBench?.reduce((sum, p) => sum + (p.impact || 0), 0) || 0;
                const lineupImpact = startedImpact + benchedImpact;
                const lineupClass = lineupImpact > 0 ? 'positive' : (lineupImpact < 0 ? 'negative' : 'neutral');
                const sectionClass = lineupImpact > 0 ? 'positive-section' : (lineupImpact < 0 ? 'negative-section' : 'neutral-section');

                let lineupItems = '';
                if (lineupChanges.movedToStarting?.length > 0) {
                    lineupItems += lineupChanges.movedToStarting.map(p => {
                        const impact = p.impact || 0;
                        const ptsClass = impact > 0 ? 'positive' : (impact < 0 ? 'negative' : 'neutral');
                        const ptsSign = impact > 0 ? '+' : '';
                        return `
                        <div class="tinkering-item">
                            <span>Started ${p.name}</span>
                            <span class="points ${ptsClass}">${ptsSign}${impact} pts</span>
                        </div>
                    `}).join('');
                }
                if (lineupChanges.movedToBench?.length > 0) {
                    lineupItems += lineupChanges.movedToBench.map(p => {
                        const impact = p.impact || 0;
                        const ptsClass = impact > 0 ? 'positive' : (impact < 0 ? 'negative' : 'neutral');
                        const ptsSign = impact > 0 ? '+' : '';
                        return `
                        <div class="tinkering-item">
                            <span>Benched ${p.name}</span>
                            <span class="points ${ptsClass}">${ptsSign}${impact} pts</span>
                        </div>
                    `}).join('');
                }
                const lineupSign = lineupImpact > 0 ? '+' : '';
                lineupHtml = `
                    <div class="tinkering-section ${sectionClass}">
                        <div class="tinkering-section-title">Lineup Changes</div>
                        ${lineupItems}
                        <div class="tinkering-section-total">
                            <span>Impact</span>
                            <span class="points ${lineupClass}">${lineupSign}${lineupImpact} pts</span>
                        </div>
                    </div>
                `;
            }

            // Build auto-sub effects section
            let autoSubHtml = '';
            if (autoSubEffects && autoSubEffects.length > 0) {
                const totalImpact = autoSubEffects.reduce((sum, p) => sum + (p.impact || 0), 0);
                const impactClass = totalImpact > 0 ? 'positive' : (totalImpact < 0 ? 'negative' : 'neutral');
                const sectionClass = totalImpact > 0 ? 'positive-section' : (totalImpact < 0 ? 'negative-section' : 'neutral-section');
                const impactSign = totalImpact > 0 ? '+' : '';

                autoSubHtml = `
                    <div class="tinkering-section ${sectionClass}">
                        <div class="tinkering-section-title ${impactClass}">Auto-Sub Effects</div>
                        ${autoSubEffects.map(p => {
                            const impact = p.impact || 0;
                            const ptsClass = impact > 0 ? 'positive' : (impact < 0 ? 'negative' : 'neutral');
                            const ptsSign = impact > 0 ? '+' : '';
                            return `
                            <div class="tinkering-item">
                                <span>${p.name}</span>
                                <span class="points ${ptsClass}">${ptsSign}${impact} pts</span>
                            </div>
                        `}).join('')}
                        <div class="tinkering-section-total">
                            <span>Impact</span>
                            <span class="points ${impactClass}">${impactSign}${totalImpact} pts</span>
                        </div>
                    </div>
                `;
            }

            // Build chip impact section (TC or BB)
            let chipImpactHtml = '';
            if (chipImpact?.tripleCaptain) {
                const tcBonus = chipImpact.tripleCaptain.bonus;
                chipImpactHtml = `
                    <div class="tinkering-section positive-section">
                        <div class="tinkering-section-title positive">Triple Captain Bonus</div>
                        <div class="tinkering-item">
                            <span>${chipImpact.tripleCaptain.playerName} (${chipImpact.tripleCaptain.basePoints} pts Ã— 3)</span>
                            <span class="points positive">+${tcBonus} pts</span>
                        </div>
                        <div class="tinkering-section-total">
                            <span>Chip Bonus</span>
                            <span class="points positive">+${tcBonus} pts</span>
                        </div>
                    </div>
                `;
            }

            if (chipImpact?.benchBoost) {
                const bbTotal = chipImpact.benchBoost.totalBonus;
                const bbClass = bbTotal > 0 ? 'positive' : (bbTotal < 0 ? 'negative' : 'neutral');
                const bbSign = bbTotal > 0 ? '+' : '';
                const sectionClass = bbTotal > 0 ? 'positive-section' : (bbTotal < 0 ? 'negative-section' : 'neutral-section');
                chipImpactHtml = `
                    <div class="tinkering-section ${sectionClass}">
                        <div class="tinkering-section-title ${bbClass}">Bench Boost</div>
                        ${chipImpact.benchBoost.players.map(p => {
                            const pClass = p.points > 0 ? 'positive' : (p.points < 0 ? 'negative' : 'neutral');
                            const pSign = p.points > 0 ? '+' : '';
                            return `
                            <div class="tinkering-item">
                                <span>${p.name}</span>
                                <span class="points ${pClass}">${pSign}${p.points} pts</span>
                            </div>
                        `}).join('')}
                        <div class="tinkering-section-total">
                            <span>Chip Bonus</span>
                            <span class="points ${bbClass}">${bbSign}${bbTotal} pts</span>
                        </div>
                    </div>
                `;
            }

            return `
                <div class="tinkering-bar" onclick="toggleTinkeringBar(this)">
                    <div class="tinkering-header">
                        <div class="tinkering-title">
                            <svg viewBox="0 0 24 24" fill="currentColor"><path d="M22.7 19l-9.1-9.1c.9-2.3.4-5-1.5-6.9-2-2-5-2.4-7.4-1.3L9 6 6 9 1.6 4.7C.4 7.1.9 10.1 2.9 12.1c1.9 1.9 4.6 2.4 6.9 1.5l9.1 9.1c.4.4 1 .4 1.4 0l2.3-2.3c.5-.4.5-1.1.1-1.4z"/></svg>
                            Tinkering Impact${chipBadge}
                        </div>
                        <div>
                            <span class="tinkering-impact ${impactClass}">${impactDisplay} pts</span>
                            <span class="tinkering-toggle">&#9660;</span>
                        </div>
                    </div>
                    <div class="tinkering-details">
                        <div class="tinkering-summary">
                            <div class="tinkering-row">
                                <span>If you kept last week's team:</span>
                                <span>${hypotheticalScore} pts</span>
                            </div>
                            <div class="tinkering-row">
                                <span>Your actual score:</span>
                                <span>${actualScore} pts</span>
                            </div>
                            ${transferCost > 0 ? `
                            <div class="tinkering-row">
                                <span>Transfer hits:</span>
                                <span class="tinkering-impact negative">-${transferCost} pts</span>
                            </div>
                            ` : ''}
                            <div class="tinkering-row total">
                                <span>NET BENEFIT:</span>
                                <span class="tinkering-impact ${impactClass}">${impactDisplay} pts</span>
                            </div>
                        </div>
                        ${transfersInHtml}
                        ${transfersOutHtml}
                        ${captainHtml}
                        ${lineupHtml}
                        ${autoSubHtml}
                        ${chipImpactHtml}
                    </div>
                </div>
            `;
        }

        function toggleTinkeringBar(element) {
            element.classList.toggle('expanded');
        }

        function showTooltip(event, playerId) {
            // Disabled: using click-to-open modal for all devices now
            return;
            const player = currentPicksData?.players.find(p => p.id === playerId);
            if (!player) return;

            const breakdown = player.pointsBreakdown || [];
            const tooltip = document.getElementById('tooltip');

            let statsHtml = `<div class="tooltip-header">${player.fullName || player.name}</div>`;

            if (breakdown.length === 0) {
                statsHtml += `<div class="tooltip-row"><span class="stat">No points yet</span><span></span><span></span></div>`;
            } else {
                breakdown.forEach(item => {
                    const ptsColor = item.points < 0 ? 'color: #e74c3c;' : 'color: #4ade80;';
                    const icon = item.icon || '';
                    statsHtml += `
                        <div class="tooltip-row">
                            <span class="stat">${icon} ${item.stat}</span>
                            <span class="value">${item.value}</span>
                            <span class="pts" style="${ptsColor}">${item.points}</span>
                        </div>`;
                });
            }

            statsHtml += `
                <div class="tooltip-row total">
                    <span class="stat">Total</span>
                    <span></span>
                    <span class="pts">${player.totalPoints || player.points}</span>
                </div>`;

            tooltip.innerHTML = statsHtml;
            tooltip.style.left = `${event.clientX + 10}px`;
            tooltip.style.top = `${event.clientY + 10}px`;
            tooltip.classList.add('visible');
        }

        function hideTooltip() {
            document.getElementById('tooltip').classList.remove('visible');
        }

        function handlePlayerClick(playerId) {
            // Show player sheet on all devices (not just mobile)
            showPlayerSheet(playerId);
        }

        function showPlayerSheet(playerId) {
            const player = currentPicksData?.players.find(p => p.id === playerId);
            if (!player) return;

            const breakdown = player.pointsBreakdown || [];
            const basePoints = player.totalPoints || player.points || 0;
            const provisionalBonus = player.provisionalBonus || 0;

            let breakdownHtml = '';
            if (breakdown.length === 0) {
                breakdownHtml = '<div class="breakdown-row"><span>No points yet</span></div>';
            } else {
                breakdown.forEach(item => {
                    const ptsClass = item.points < 0 ? 'negative' : '';
                    const icon = item.icon || '';
                    breakdownHtml += `
                        <div class="breakdown-row">
                            <span class="breakdown-stat">${icon} ${item.stat}</span>
                            <span class="breakdown-value">${item.value}</span>
                            <span class="breakdown-pts ${ptsClass}">${item.points} pts</span>
                        </div>
                    `;
                });
            }

            // Add provisional bonus row if applicable (matching match view modal)
            if (provisionalBonus > 0) {
                breakdownHtml += `
                    <div class="breakdown-row" style="border-top: 1px dashed rgba(255,255,255,0.2);">
                        <span class="breakdown-stat" style="color: #00ff85;">â­ Provisional bonus</span>
                        <span class="breakdown-value" style="color: #00ff85;">[${player.bps} BPS]</span>
                        <span class="breakdown-pts" style="color: #00ff85;">+${provisionalBonus} pts</span>
                    </div>
                `;
            }

            const teamCode = player.teamCode || 1;
            const shirtSuffix = player.positionId === 1 ? '_1' : '';
            const shirtUrl = `https://fantasy.premierleague.com/dist/img/shirts/standard/shirt_${teamCode}${shirtSuffix}-110.webp`;

            const totalDisplay = provisionalBonus > 0
                ? `${basePoints}<span class="provisional-bonus" style="font-size: 0.5em;">+${provisionalBonus}</span>`
                : `${basePoints}`;
            const totalBreakdown = provisionalBonus > 0
                ? `${basePoints} + ${provisionalBonus} pts`
                : `${basePoints} pts`;

            let html = `
                <div class="player-sheet-header">
                    <div class="player-sheet-badge">
                        <img src="${shirtUrl}" alt="${player.teamName}">
                    </div>
                    <div class="player-sheet-info">
                        <h3>${player.fullName || player.name}</h3>
                        <p>${player.teamName} - ${player.position}</p>
                    </div>
                    <div class="player-sheet-points">${totalDisplay}</div>
                </div>
                <div class="points-breakdown">
                    <div class="breakdown-header">
                        <span>Statistic</span>
                        <span style="text-align:center">Value</span>
                        <span style="text-align:right">Points</span>
                    </div>
                    ${breakdownHtml}
                    <div class="breakdown-total">
                        <span>Total</span>
                        <span></span>
                        <span>${totalBreakdown}</span>
                    </div>
                </div>
            `;

            document.getElementById('player-sheet').innerHTML = html;
            document.getElementById('sheet-overlay').classList.add('visible');
            document.getElementById('player-sheet').classList.add('visible');

            // Track open player sheet for background refresh
            currentPlayerSheetId = playerId;
            currentPlayerSheetParent = 'manager';

            // Push to browser history for back button support (nested within manager modal)
            pushModalState('player-sheet', {
                playerId,
                parentModal: 'manager',
                parentEntryId: currentModalEntryId,
                parentGw: currentModalGW
            });
        }

        function closePlayerSheet() {
            // Use history.back() to trigger popstate handler for proper history management
            window.history.back();
        }

        // Fixtures Modal Functions
        function openFixturesModal() {
            if (!weekData?.fixtures) return;

            const fixtures = weekData.fixtures;
            document.getElementById('fixtures-modal-title').textContent = `GW ${weekData.currentGW} Fixtures`;

            let html = fixtures.map(f => {
                let statusClass = '';
                let statusBadge = '';

                if (f.started && !f.finished) {
                    statusClass = 'live';
                    statusBadge = `<span class="fixture-status live">${f.minutes || 0}'</span>`;
                } else if (f.finished) {
                    statusClass = 'finished';
                    statusBadge = `<span class="fixture-status ft">FT</span>`;
                }

                const scoreOrTime = f.started
                    ? `<div class="fixture-score">${f.homeScore ?? 0} - ${f.awayScore ?? 0}</div>`
                    : `<div class="fixture-kickoff">${formatKickoffTime(f.kickoff)}</div>`;

                return `
                    <div class="fixture-item ${statusClass}" onclick="openMatchModal(${f.id});">
                        <span class="fixture-team home">${f.home}</span>
                        ${scoreOrTime}
                        <span class="fixture-team away">${f.away}</span>
                        ${statusBadge}
                    </div>
                `;
            }).join('');

            document.getElementById('fixtures-modal-body').innerHTML = html;
            document.getElementById('fixtures-modal-overlay').classList.add('active');
            document.body.style.overflow = 'hidden';

            // Push to browser history for back button support
            pushModalState('fixtures');
        }

        function closeFixturesModal(event) {
            if (event && event.target !== event.currentTarget) return;
            // Use history.back() to trigger popstate handler for proper history management
            window.history.back();
        }

        // Match Modal Functions
        async function fetchMatchStats(fixtureId, fixture, { showLoading = true } = {}) {
            const body = document.getElementById('match-modal-body');
            const cached = matchStatsCache[fixtureId];

            // Resolve fixture from weekData if not provided (e.g. retry button)
            if (!fixture) fixture = cached?.fixture || weekData?.fixtures?.find(f => f.id === fixtureId);

            // Show cached data immediately if available, otherwise show loading spinner
            if (cached) {
                renderMatchStats(cached.data, fixture);
            } else if (showLoading) {
                body.innerHTML = '<div class="loading" style="text-align: center; padding: 2rem;">Loading match data...</div>';
            }

            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 30000);
                const res = await fetch(`/api/fixture/${fixtureId}/stats`, { signal: controller.signal });
                clearTimeout(timeoutId);
                const data = await res.json();
                if (!data || data.error) {
                    // Only overwrite if we have no cached data to keep showing
                    if (!cached) {
                        body.innerHTML = `<div class="loading" style="text-align: center; padding: 2rem;">
                            <div>${data?.error || 'No data available'}</div>
                            <button onclick="fetchMatchStats(${fixtureId}, null)" style="margin-top: 1rem; padding: 0.5rem 1.2rem; background: var(--accent); color: var(--primary); border: none; border-radius: 6px; cursor: pointer; font-weight: 600;">Retry</button>
                        </div>`;
                    }
                    return;
                }
                matchStatsCache[fixtureId] = { data, fixture };
                renderMatchStats(data, fixture);
            } catch (e) {
                // Only show error if we have no cached data already displayed
                if (!cached) {
                    const msg = e.name === 'AbortError' ? 'Request timed out' : 'Failed to load match data';
                    body.innerHTML = `<div class="loading" style="text-align: center; padding: 2rem;">
                        <div style="color: var(--danger);">${msg}</div>
                        <button onclick="fetchMatchStats(${fixtureId}, null)" style="margin-top: 1rem; padding: 0.5rem 1.2rem; background: var(--accent); color: var(--primary); border: none; border-radius: 6px; cursor: pointer; font-weight: 600;">Retry</button>
                    </div>`;
                }
            }
        }

        async function openMatchModal(fixtureId) {
            const fixture = weekData?.fixtures?.find(f => f.id === fixtureId);
            if (!fixture) return;

            // Keep fixtures modal active underneath (match overlay renders on top due to DOM order).
            // This way, closing the match instantly reveals the already-rendered fixtures list.

            // Track current fixture for player sheet history
            currentMatchFixtureId = fixtureId;

            const score = fixture.started
                ? `<span class="match-score">${fixture.homeScore ?? 0} - ${fixture.awayScore ?? 0}</span>`
                : 'vs';
            document.getElementById('match-teams').innerHTML = `${fixture.home} ${score} ${fixture.away}`;

            let status = '';
            if (fixture.finished) status = 'Full Time';
            else if (fixture.started) status = `${fixture.minutes || 0}'`;
            else status = formatKickoffTime(fixture.kickoff);
            document.getElementById('match-status').textContent = status;

            document.getElementById('match-modal-overlay').classList.add('active');
            document.body.style.overflow = 'hidden';

            // Push to browser history for back button support
            pushModalState('match', { fixtureId });

            // Fetch match stats (shows cached data immediately if available)
            await fetchMatchStats(fixtureId, fixture);
        }

        function closeMatchModal(event) {
            if (event && event.target !== event.currentTarget) return;
            // Use history.back() to trigger popstate handler for proper history management
            window.history.back();
        }

        // Event impact tracking
        function showEventImpact(eventIdx) {
            // Hide bonus popup if visible
            hideBonusPopup();

            // Toggle selection
            if (selectedEventIdx === eventIdx) {
                clearEventImpact();
                return;
            }

            selectedEventIdx = eventIdx;

            // Update ticker event styling
            document.querySelectorAll('.ticker-event').forEach((el, i) => {
                el.classList.toggle('selected', i === eventIdx);
            });

            // Re-render table with impact badges
            renderTable();
        }

        function clearEventImpact() {
            selectedEventIdx = null;
            selectedChangeIdx = null;
            selectedChronoIdx = null;
            hideBonusPopup();
            document.querySelectorAll('.ticker-event').forEach(el => {
                el.classList.remove('selected');
            });

            if (currentView === 'season') {
                renderStandingsTable();
            } else if (currentView === 'form') {
                renderFormTable();
            } else {
                renderTable();
            }
        }

        // Bonus popup functions
        function showBonusPopup(clickEvent, eventIdx) {
            clickEvent.stopPropagation();

            const event = weekData?.liveEvents?.[eventIdx];
            if (!event || !event.isBonus) return;

            // Select this event for impact display
            selectedEventIdx = eventIdx;
            document.querySelectorAll('.ticker-event').forEach((el, i) => {
                el.classList.toggle('selected', i === eventIdx);
            });

            // Build popup content
            let html = `<div class="bonus-popup-header">${event.match} - Bonus Points</div>`;

            if (event.bonusPlayers && event.bonusPlayers.length > 0) {
                html += event.bonusPlayers.map(p => `
                    <div class="bonus-player-row">
                        <span class="name">${p.name}<span class="bps">${p.bps} BPS</span></span>
                        <span class="bonus-pts">+${p.bonus}</span>
                    </div>
                `).join('');
            }

            if (event.nearMissPlayers && event.nearMissPlayers.length > 0) {
                html += `<div class="bonus-section-label">Just outside:</div>`;
                html += event.nearMissPlayers.map(p => `
                    <div class="bonus-player-row near-miss">
                        <span class="name">${p.name}<span class="bps">${p.bps} BPS</span></span>
                        <span class="bonus-pts">-</span>
                    </div>
                `).join('');
            }

            const popup = document.getElementById('bonus-popup');
            popup.innerHTML = html;

            // Position popup above the ticker event (ticker is at bottom of screen)
            const rect = clickEvent.target.closest('.ticker-event').getBoundingClientRect();
            popup.style.left = `${Math.min(rect.left, window.innerWidth - 260)}px`;
            popup.style.top = 'auto';
            popup.style.bottom = `${window.innerHeight - rect.top + 8}px`;
            popup.classList.add('visible');

            // Re-render table with impact
            renderTable();
        }

        function hideBonusPopup() {
            const popup = document.getElementById('bonus-popup');
            if (popup) popup.classList.remove('visible');
        }

        // Close bonus popup when clicking outside
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.bonus-popup') && !e.target.closest('.ticker-event.bonus')) {
                hideBonusPopup();
            }
        });

        // Change event handlers
        function showBonusChangePopup(clickEvent, changeIdx) {
            clickEvent.stopPropagation();
            hideBonusPopup();

            const changeEvent = weekData?.changeEvents?.[changeIdx];
            if (!changeEvent || changeEvent.type !== 'bonus_change') return;

            selectedChangeIdx = changeIdx;
            selectedEventIdx = null; // Clear regular event selection

            // Build popup content showing changes
            let html = `<div class="bonus-popup-header">${changeEvent.match} - Bonus Changed${changeEvent.minute ? ` (${changeEvent.minute}')` : ''}</div>`;

            changeEvent.changes.forEach(c => {
                const arrow = c.impact > 0 ? 'â–²' : (c.impact < 0 ? 'â–¼' : '');
                const impactClass = c.impact > 0 ? 'positive' : (c.impact < 0 ? 'negative' : '');
                const fromTo = c.from > 0 || c.to > 0 ? ` (${c.from}â†’${c.to})` : '';
                html += `
                    <div class="bonus-player-row ${impactClass}">
                        <span class="name">${arrow} ${c.player}${fromTo}</span>
                        <span class="bonus-pts" style="color: ${c.impact > 0 ? 'var(--accent)' : 'var(--danger)'}">${c.impact > 0 ? '+' : ''}${c.impact}</span>
                    </div>
                `;
            });

            const popup = document.getElementById('bonus-popup');
            popup.innerHTML = html;

            const rect = clickEvent.target.closest('.ticker-event').getBoundingClientRect();
            popup.style.left = `${Math.min(rect.left, window.innerWidth - 260)}px`;
            popup.style.top = 'auto';
            popup.style.bottom = `${window.innerHeight - rect.top + 8}px`;
            popup.classList.add('visible');

            // Show impact on managers
            renderTableWithChangeImpact(changeEvent);
        }

        function showCSLostImpact(changeIdx) {
            hideBonusPopup();

            const changeEvent = weekData?.changeEvents?.[changeIdx];
            if (!changeEvent || changeEvent.type !== 'cs_lost') return;

            selectedChangeIdx = changeIdx;
            selectedEventIdx = null;

            // Show impact on managers who have defenders from this team
            renderTableWithChangeImpact(changeEvent);
        }

        function showDefconImpact(changeIdx) {
            hideBonusPopup();

            const changeEvent = weekData?.changeEvents?.[changeIdx];
            if (!changeEvent || changeEvent.type !== 'defcon_gained') return;

            selectedChangeIdx = changeIdx;
            selectedEventIdx = null;

            // Show impact on managers who own this player
            renderTableWithChangeImpact(changeEvent);
        }

        // Chronological event handlers
        function showChronoEventImpact(chronoIdx) {
            hideBonusPopup();

            const chronoEvent = weekData?.chronologicalEvents?.[chronoIdx];
            if (!chronoEvent) return;

            // Toggle selection
            if (selectedChronoIdx === chronoIdx) {
                clearChronoEventImpact();
                return;
            }

            selectedChronoIdx = chronoIdx;
            selectedEventIdx = null;
            selectedChangeIdx = null;

            // Update ticker event styling
            document.querySelectorAll('.ticker-event').forEach(el => {
                const idx = el.getAttribute('data-chrono-idx');
                el.classList.toggle('selected', idx !== null && parseInt(idx) === chronoIdx);
            });

            // Re-render table with impact
            renderTableWithChronoImpact(chronoEvent);
        }

        function showChronoBonusPopup(clickEvent, chronoIdx) {
            clickEvent.stopPropagation();

            // Toggle: if clicking the same event, close popup
            if (selectedChronoIdx === chronoIdx) {
                clearChronoEventImpact();
                return;
            }

            hideBonusPopup();

            const chronoEvent = weekData?.chronologicalEvents?.[chronoIdx];
            if (!chronoEvent || chronoEvent.type !== 'bonus_change') return;

            selectedChronoIdx = chronoIdx;
            selectedEventIdx = null;
            selectedChangeIdx = null;

            // Build popup content showing changes
            let html = `<div class="bonus-popup-header">${chronoEvent.match} - Bonus Changed</div>`;

            (chronoEvent.changes || []).forEach(c => {
                const arrow = c.impact > 0 ? 'â–²' : (c.impact < 0 ? 'â–¼' : '');
                const impactClass = c.impact > 0 ? 'positive' : (c.impact < 0 ? 'negative' : '');
                const fromTo = c.from > 0 || c.to > 0 ? ` (${c.from}â†’${c.to})` : '';
                html += `
                    <div class="bonus-player-row ${impactClass}">
                        <span class="name">${arrow} ${c.player}${fromTo}</span>
                        <span class="bonus-pts" style="color: ${c.impact > 0 ? 'var(--accent)' : 'var(--danger)'}">${c.impact > 0 ? '+' : ''}${c.impact}</span>
                    </div>
                `;
            });

            const popup = document.getElementById('bonus-popup');
            popup.innerHTML = html;

            const rect = clickEvent.target.closest('.ticker-event').getBoundingClientRect();
            popup.style.left = `${Math.min(rect.left, window.innerWidth - 260)}px`;
            popup.style.top = 'auto';
            popup.style.bottom = `${window.innerHeight - rect.top + 8}px`;
            popup.classList.add('visible');

            // Update ticker event styling
            document.querySelectorAll('.ticker-event').forEach(el => {
                const idx = el.getAttribute('data-chrono-idx');
                el.classList.toggle('selected', idx !== null && parseInt(idx) === chronoIdx);
            });

            // Show impact on managers
            renderTableWithChronoImpact(chronoEvent);
        }

        function clearChronoEventImpact() {
            selectedChronoIdx = null;
            hideBonusPopup();
            document.querySelectorAll('.ticker-event').forEach(el => {
                el.classList.remove('selected');
            });

            if (currentView === 'season') {
                renderStandingsTable();
            } else if (currentView === 'form') {
                renderFormTable();
            } else {
                renderTable();
            }
        }

        function showTeamEventPopup(clickEvent, chronoIdx) {
            clickEvent.stopPropagation();

            // Toggle: if clicking the same event, close popup
            if (selectedChronoIdx === chronoIdx) {
                clearChronoEventImpact();
                return;
            }

            hideBonusPopup();

            const chronoEvent = weekData?.chronologicalEvents?.[chronoIdx];
            if (!chronoEvent || (chronoEvent.type !== 'team_clean_sheet' && chronoEvent.type !== 'team_goals_conceded')) return;

            selectedChronoIdx = chronoIdx;
            selectedEventIdx = null;
            selectedChangeIdx = null;

            // Build popup content showing affected players
            const eventLabel = chronoEvent.type === 'team_clean_sheet' ? 'Clean Sheet' : 'Goals Conceded';
            let html = `<div class="bonus-popup-header">${chronoEvent.team} - ${eventLabel}</div>`;

            (chronoEvent.affectedPlayers || []).forEach(p => {
                const pointsClass = p.points >= 0 ? 'positive' : 'negative';
                const pointsDisplay = p.points >= 0 ? `+${p.points}` : `${p.points}`;
                html += `
                    <div class="bonus-player-row ${pointsClass}">
                        <span class="name">${p.player}</span>
                        <span class="bonus-pts" style="color: ${p.points >= 0 ? 'var(--accent)' : 'var(--danger)'}">${pointsDisplay}</span>
                    </div>
                `;
            });

            const popup = document.getElementById('bonus-popup');
            popup.innerHTML = html;

            const rect = clickEvent.target.closest('.ticker-event').getBoundingClientRect();
            popup.style.left = `${Math.min(rect.left, window.innerWidth - 260)}px`;
            popup.style.top = 'auto';
            popup.style.bottom = `${window.innerHeight - rect.top + 8}px`;
            popup.classList.add('visible');

            // Update ticker event styling
            document.querySelectorAll('.ticker-event').forEach(el => {
                const idx = el.getAttribute('data-chrono-idx');
                el.classList.toggle('selected', idx !== null && parseInt(idx) === chronoIdx);
            });

            // Show impact on managers
            renderTableWithChronoImpact(chronoEvent);
        }

        function renderTableWithChronoImpact(chronoEvent) {
            // If in season view, render standings with chrono impact instead
            if (currentView === 'season') {
                renderStandingsTableWithImpact(chronoEvent, 'chrono');
                return;
            }
            // Form view doesn't show event impacts
            if (currentView === 'form') return;

            // Re-render table but use chrono event for impact calculation
            let html = `
                <table>
                    <thead>
                        <tr>
                            <th style="width:6%" class="sortable ${sortClass('gwRank')}" onclick="sortTable('gwRank')">#</th>
                            <th style="width:30%" class="col-manager sortable ${sortClass('manager')}" onclick="sortTable('manager')">Manager</th>
                            <th style="width:30%" class="col-captain sortable ${sortClass('captain')}" onclick="sortTable('captain')">Captain</th>
                            <th style="width:17%" class="num sortable ${sortClass('gwScore')}" onclick="sortTable('gwScore')">Pts</th>
                            <th style="width:17%" class="num sortable ${sortClass('benchPoints')}" onclick="sortTable('benchPoints')">Bench</th>
                        </tr>
                    </thead>
                    <tbody>
            `;

            const hasHighlight = highlightState.type !== null;

            weekData.managers.forEach(m => {
                const rankClass = m.gwRank <= 3 ? `rank-${m.gwRank}` : '';

                const hl = hasHighlight ? getHighlightResult(m) : { match: false, defCount: 0 };
                const hlClass = hasHighlight ? (hl.match ? 'hl-match' : 'hl-dimmed') : '';

                let pills = [];
                if (m.activeChip) {
                    pills.push(`<span class="info-pill chip-pill ${CHIP_CLASSES[m.activeChip]}">${CHIP_NAMES[m.activeChip]}</span>`);
                }
                if (m.playersLeft > 0) {
                    pills.push(`<span class="info-pill left-pill">${m.playersLeft} left</span>`);
                }
                if (hasHighlight && hl.match && hl.defCount > 0) {
                    pills.push(`<span class="info-pill def-count-badge">${hl.defCount} DEF</span>`);
                }
                const pillsHtml = pills.length > 0 ? `<div class="manager-pills">${pills.join('')}</div>` : '';

                // Calculate impact from chrono event
                const impact = getChronoEventImpactForManager(m, chronoEvent);
                let impactHtml = '';
                if (impact !== null && impact !== 0) {
                    const isPositive = impact >= 0;
                    const impactClass = isPositive ? 'positive' : 'negative';
                    const arrow = isPositive ? 'â–²' : 'â–¼';
                    impactHtml = `<span class="event-impact ${impactClass}"><span class="arrow">${arrow}</span>${Math.abs(impact)}</span>`;
                }

                html += `
                    <tr class="clickable ${hlClass}" data-entry-id="${m.entryId}" onclick="openManagerModal(${m.entryId})">
                        <td class="rank-cell ${rankClass}">${m.gwRank}</td>
                        <td class="col-manager">
                            <strong>${m.name}</strong>
                            <div class="team-name">${m.team}</div>
                            ${pillsHtml}
                        </td>
                        <td class="captain-cell">
                            ${m.captainName || '-'}
                            ${m.viceCaptainName ? `<div class="vice-captain">${m.viceCaptainName}</div>` : ''}
                        </td>
                        <td class="num"><span class="badge badge-success">${m.gwScore}</span>${impactHtml}</td>
                        <td class="num">${m.benchPoints}</td>
                    </tr>
                `;
            });

            html += '</tbody></table>';
            document.querySelector('.table-container').innerHTML = html;
        }

        // Check if a player is in the manager's active scoring squad
        // (starting 11, or also bench when bench boost is active)
        function isInActiveSquad(manager, playerId) {
            if (manager.starting11 && manager.starting11.includes(playerId)) return true;
            if (manager.activeChip === 'bboost' && manager.benchPlayerIds && manager.benchPlayerIds.includes(playerId)) return true;
            return false;
        }

        function getChronoEventImpactForManager(manager, event) {
            if (!event) return null;

            // For bonus changes, check if manager owns any affected players
            if (event.type === 'bonus_change' && event.changes) {
                let totalImpact = 0;
                event.changes.forEach(c => {
                    if (isInActiveSquad(manager, c.elementId)) {
                        // Check if captain (3x for TC, 2x for normal captain)
                        const multiplier = manager.captainId === c.elementId ? (manager.activeChip === '3xc' ? 3 : 2) : 1;
                        totalImpact += c.impact * multiplier;
                    }
                });
                return totalImpact;
            }

            // For team events (clean sheets and goals conceded grouped by team)
            if ((event.type === 'team_clean_sheet' || event.type === 'team_goals_conceded') && event.affectedPlayers) {
                let totalImpact = 0;
                event.affectedPlayers.forEach(p => {
                    if (isInActiveSquad(manager, p.elementId)) {
                        // Check if captain (3x for TC, 2x for normal captain)
                        const multiplier = manager.captainId === p.elementId ? (manager.activeChip === '3xc' ? 3 : 2) : 1;
                        totalImpact += p.points * multiplier;
                    }
                });
                return totalImpact;
            }

            // For player events, check if manager owns this player
            if (event.elementId) {
                if (isInActiveSquad(manager, event.elementId)) {
                    // Check if captain (3x for TC, 2x for normal captain)
                    const multiplier = manager.captainId === event.elementId ? (manager.activeChip === '3xc' ? 3 : 2) : 1;
                    return event.points * multiplier;
                }
            }

            return null;
        }

        function renderTableWithChangeImpact(changeEvent) {
            // If in season view, render standings with change impact instead
            if (currentView === 'season') {
                renderStandingsTableWithImpact(changeEvent, 'change');
                return;
            }
            // Form view doesn't show event impacts
            if (currentView === 'form') return;

            // Re-render table but use change event for impact calculation
            let html = `
                <table>
                    <thead>
                        <tr>
                            <th style="width:6%" class="sortable ${sortClass('gwRank')}" onclick="sortTable('gwRank')">#</th>
                            <th style="width:30%" class="col-manager sortable ${sortClass('manager')}" onclick="sortTable('manager')">Manager</th>
                            <th style="width:30%" class="col-captain sortable ${sortClass('captain')}" onclick="sortTable('captain')">Captain</th>
                            <th style="width:17%" class="num sortable ${sortClass('gwScore')}" onclick="sortTable('gwScore')">Pts</th>
                            <th style="width:17%" class="num sortable ${sortClass('benchPoints')}" onclick="sortTable('benchPoints')">Bench</th>
                        </tr>
                    </thead>
                    <tbody>
            `;

            const hasHighlight = highlightState.type !== null;

            weekData.managers.forEach(m => {
                const rankClass = m.gwRank <= 3 ? `rank-${m.gwRank}` : '';

                const hl = hasHighlight ? getHighlightResult(m) : { match: false, defCount: 0 };
                const hlClass = hasHighlight ? (hl.match ? 'hl-match' : 'hl-dimmed') : '';

                let pills = [];
                if (m.activeChip) {
                    pills.push(`<span class="info-pill chip-pill ${CHIP_CLASSES[m.activeChip]}">${CHIP_NAMES[m.activeChip]}</span>`);
                }
                if (m.playersLeft > 0) {
                    pills.push(`<span class="info-pill left-pill">${m.playersLeft} left</span>`);
                }
                if (hasHighlight && hl.match && hl.defCount > 0) {
                    pills.push(`<span class="info-pill def-count-badge">${hl.defCount} DEF</span>`);
                }
                const pillsHtml = pills.length > 0 ? `<div class="manager-pills">${pills.join('')}</div>` : '';

                // Calculate impact from change event
                const impact = getChangeEventImpactForManager(m, changeEvent);
                let impactHtml = '';
                if (impact !== null && impact !== 0) {
                    const isPositive = impact >= 0;
                    const impactClass = isPositive ? 'positive' : 'negative';
                    const arrow = isPositive ? 'â–²' : 'â–¼';
                    impactHtml = `<span class="event-impact ${impactClass}"><span class="arrow">${arrow}</span>${Math.abs(impact)}</span>`;
                }

                html += `
                    <tr class="clickable ${hlClass}" data-entry-id="${m.entryId}" onclick="openManagerModal(${m.entryId})">
                        <td class="rank-cell ${rankClass}">${m.gwRank}</td>
                        <td class="col-manager">
                            <strong>${m.name}</strong>
                            <div class="team-name">${m.team}</div>
                            ${pillsHtml}
                        </td>
                        <td class="captain-cell">
                            ${m.captainName || '-'}
                            ${m.viceCaptainName ? `<div class="vice-captain">${m.viceCaptainName}</div>` : ''}
                        </td>
                        <td class="num"><span class="badge badge-success">${m.gwScore}</span>${impactHtml}</td>
                        <td class="num">${m.benchPoints}</td>
                    </tr>
                `;
            });

            html += '</tbody></table>';
            document.querySelector('.table-container').innerHTML = html;
        }

        function getChangeEventImpactForManager(manager, changeEvent) {
            if (!changeEvent || !manager.starting11) return null;

            if (changeEvent.type === 'bonus_change') {
                let totalImpact = 0;
                changeEvent.changes.forEach(c => {
                    if (isInActiveSquad(manager, c.elementId)) {
                        let multiplier = 1;
                        if (manager.captainId === c.elementId) {
                            multiplier = manager.activeChip === '3xc' ? 3 : 2;
                        }
                        totalImpact += c.impact * multiplier;
                    }
                });
                return totalImpact !== 0 ? totalImpact : null;
            }

            if (changeEvent.type === 'cs_lost') {
                if (manager.playerTeamMap && manager.defenderIds) {
                    const defendersFromTeam = manager.defenderIds.filter(pid =>
                        manager.playerTeamMap[pid] === changeEvent.teamId && isInActiveSquad(manager, pid)
                    );
                    if (defendersFromTeam.length > 0) {
                        return changeEvent.points * defendersFromTeam.length; // -4 per defender
                    }
                }
                return null;
            }

            if (changeEvent.type === 'defcon_gained') {
                if (isInActiveSquad(manager, changeEvent.elementId)) {
                    let multiplier = 1;
                    if (manager.captainId === changeEvent.elementId) {
                        multiplier = manager.activeChip === '3xc' ? 3 : 2;
                    }
                    return changeEvent.points * multiplier;
                }
                return null;
            }

            return null;
        }

        function getEventImpactForManager(manager) {
            if (selectedEventIdx === null || !weekData?.liveEvents) return null;

            const event = weekData.liveEvents[selectedEventIdx];
            if (!event || !manager.starting11) return null;

            // Handle bonus events - sum up bonus for all owned players
            if (event.isBonus && event.bonusPlayers) {
                let totalBonus = 0;
                event.bonusPlayers.forEach(bp => {
                    if (isInActiveSquad(manager, bp.elementId)) {
                        let multiplier = 1;
                        if (manager.captainId === bp.elementId) {
                            multiplier = manager.activeChip === '3xc' ? 3 : 2;
                        }
                        totalBonus += bp.bonus * multiplier;
                    }
                });
                return totalBonus > 0 ? totalBonus : null;
            }

            // Handle team events (clean_sheet, goals_conceded)
            if (event.isTeamEvent && event.teamId) {
                if (manager.playerTeamMap && manager.defenderIds) {
                    // Count how many GK/DEF the manager has from this team in active squad
                    const defendersFromTeam = manager.defenderIds.filter(pid =>
                        manager.playerTeamMap[pid] === event.teamId && isInActiveSquad(manager, pid)
                    );

                    if (defendersFromTeam.length > 0) {
                        // Clean sheet: 4 pts per GK/DEF
                        // Goals conceded: points is already negative (-1 per 2 goals)
                        return event.points * defendersFromTeam.length;
                    }
                }
                return null;
            }

            // Regular player events - check if manager has this player in active squad
            if (!isInActiveSquad(manager, event.elementId)) return null;

            // Calculate points (doubled for captain, tripled for TC)
            let multiplier = 1;
            if (manager.captainId === event.elementId) {
                multiplier = manager.activeChip === '3xc' ? 3 : 2;
            }

            return event.points * multiplier;
        }

        function showMatchPlayerSheet(playerId) {
            if (!currentMatchStatsData) return;

            // Find player in home or away teams
            const allPlayers = [
                ...(currentMatchStatsData.home?.starters || []),
                ...(currentMatchStatsData.home?.subs || []),
                ...(currentMatchStatsData.away?.starters || []),
                ...(currentMatchStatsData.away?.subs || [])
            ];
            const player = allPlayers.find(p => p.id === playerId);
            if (!player) return;

            const breakdown = player.pointsBreakdown || [];
            const basePoints = player.points || 0;
            const provisionalBonus = player.provisionalBonus || 0;

            let breakdownHtml = '';
            if (breakdown.length === 0) {
                breakdownHtml = '<div class="breakdown-row"><span>No points yet</span></div>';
            } else {
                breakdown.forEach(item => {
                    const ptsClass = item.points < 0 ? 'negative' : '';
                    const icon = item.icon || '';
                    breakdownHtml += `
                        <div class="breakdown-row">
                            <span class="breakdown-stat">${icon} ${item.stat}</span>
                            <span class="breakdown-value">${item.value}</span>
                            <span class="breakdown-pts ${ptsClass}">${item.points} pts</span>
                        </div>
                    `;
                });
            }

            // Add provisional bonus row if applicable
            if (provisionalBonus > 0) {
                breakdownHtml += `
                    <div class="breakdown-row" style="border-top: 1px dashed rgba(255,255,255,0.2);">
                        <span class="breakdown-stat" style="color: #00ff85;">â­ Provisional bonus</span>
                        <span class="breakdown-value" style="color: #00ff85;">[${player.bps} BPS]</span>
                        <span class="breakdown-pts" style="color: #00ff85;">+${provisionalBonus} pts</span>
                    </div>
                `;
            }

            const teamCode = player.teamCode || 1;
            const shirtSuffix = player.positionId === 1 ? '_1' : '';
            const shirtUrl = `https://fantasy.premierleague.com/dist/img/shirts/standard/shirt_${teamCode}${shirtSuffix}-110.webp`;

            const totalDisplay = provisionalBonus > 0
                ? `${basePoints}<span class="provisional-bonus" style="font-size: 0.5em;">+${provisionalBonus}</span>`
                : `${basePoints}`;
            const totalBreakdown = provisionalBonus > 0
                ? `${basePoints} + ${provisionalBonus} pts`
                : `${basePoints} pts`;

            let html = `
                <div class="player-sheet-header">
                    <div class="player-sheet-badge">
                        <img src="${shirtUrl}" alt="${player.teamName}">
                    </div>
                    <div class="player-sheet-info">
                        <h3>${player.fullName || player.name}</h3>
                        <p>${player.teamName} - ${player.position}</p>
                    </div>
                    <div class="player-sheet-points">${totalDisplay}</div>
                </div>
                <div class="points-breakdown">
                    <div class="breakdown-header">
                        <span>Statistic</span>
                        <span style="text-align:center">Value</span>
                        <span style="text-align:right">Points</span>
                    </div>
                    ${breakdownHtml}
                    <div class="breakdown-total">
                        <span>Total</span>
                        <span></span>
                        <span>${totalBreakdown}</span>
                    </div>
                </div>
            `;

            document.getElementById('player-sheet').innerHTML = html;
            document.getElementById('sheet-overlay').classList.add('visible');
            document.getElementById('player-sheet').classList.add('visible');

            // Track open player sheet for background refresh
            currentPlayerSheetId = playerId;
            currentPlayerSheetParent = 'match';

            // Push to browser history for back button support (nested within match modal)
            pushModalState('player-sheet', {
                playerId,
                parentModal: 'match',
                parentFixtureId: currentMatchFixtureId
            });
        }

        function renderMatchStats(data, fixture) {
            if (!data || data.error) {
                document.getElementById('match-modal-body').innerHTML = `<div class="loading">${data?.error || 'No data available'}</div>`;
                return;
            }

            // Store data for player click handler
            currentMatchStatsData = data;

            // Extract starters and subs from new data structure
            const homeStarters = data.home?.starters || [];
            const homeSubs = data.home?.subs || [];
            const awayStarters = data.away?.starters || [];
            const awaySubs = data.away?.subs || [];

            const homePlayers = [...homeStarters, ...homeSubs];
            const awayPlayers = [...awayStarters, ...awaySubs];
            const allPlayers = [...homePlayers, ...awayPlayers];

            // Helper to get short position indicator
            const getPositionIndicator = (position) => {
                const map = { 'GKP': 'K', 'DEF': 'D', 'MID': 'M', 'FWD': 'F' };
                return map[position] || '?';
            };

            // Helper to render player icons with overlay count badge
            const renderIcons = (p) => {
                let icons = '';
                // Only show clean sheet for GKP, DEF, MID (not FWD - they don't get points for it)
                if (p.cleanSheet && p.position !== 'FWD') icons += `<span class="player-icon cs" title="Clean Sheet">ðŸ›¡ï¸</span>`;
                if (p.goals) {
                    icons += `<span class="player-icon goal" title="${p.goals} goal${p.goals > 1 ? 's' : ''}">âš½${p.goals > 1 ? `<span class="icon-count">${p.goals}</span>` : ''}</span>`;
                }
                if (p.assists) {
                    icons += `<span class="player-icon assist" title="${p.assists} assist${p.assists > 1 ? 's' : ''}">ðŸ‘Ÿ${p.assists > 1 ? `<span class="icon-count">${p.assists}</span>` : ''}</span>`;
                }
                if (p.yellowCard) icons += `<span class="player-icon yellow" title="Yellow Card">ðŸŸ¨</span>`;
                if (p.redCard) icons += `<span class="player-icon red" title="Red Card">ðŸŸ¥</span>`;
                return icons;
            };

            // Render home player row: Name+icons left aligned, score on right
            const renderHomePlayerRow = (p) => {
                if (!p) return '<div class="player-row-sbs" style="visibility: hidden;"></div>';
                const ptsClass = p.points > 0 ? 'positive' : (p.points < 0 ? 'negative' : 'zero');
                const icons = renderIcons(p);
                const posIndicator = `<span class="pos-indicator">[${getPositionIndicator(p.position)}]</span>`;
                const bonusDisplay = p.provisionalBonus > 0
                    ? `<span class="provisional-bonus">+${p.provisionalBonus}</span>` : '';
                return `
                    <div class="player-row-sbs clickable" onclick="showMatchPlayerSheet(${p.id})">
                        <div class="player-name-group">
                            ${posIndicator} <span class="player-name">${p.name}</span>
                            ${icons ? `<div class="player-icons">${icons}</div>` : ''}
                        </div>
                        <div class="player-pts ${ptsClass}">${p.points}${bonusDisplay}</div>
                    </div>
                `;
            };

            // Render away player row: Score on left, icons+name right aligned
            const renderAwayPlayerRow = (p) => {
                if (!p) return '<div class="player-row-sbs" style="visibility: hidden;"></div>';
                const ptsClass = p.points > 0 ? 'positive' : (p.points < 0 ? 'negative' : 'zero');
                const icons = renderIcons(p);
                const posIndicator = `<span class="pos-indicator">[${getPositionIndicator(p.position)}]</span>`;
                const bonusDisplay = p.provisionalBonus > 0
                    ? `<span class="provisional-bonus">+${p.provisionalBonus}</span>` : '';
                return `
                    <div class="player-row-sbs clickable" onclick="showMatchPlayerSheet(${p.id})">
                        <div class="player-pts ${ptsClass}">${p.points}${bonusDisplay}</div>
                        <div class="player-name-group">
                            ${icons ? `<div class="player-icons">${icons}</div>` : ''}
                            <span class="player-name">${p.name}</span> ${posIndicator}
                        </div>
                    </div>
                `;
            };

            // Build side-by-side team columns with starters/subs separation
            let homeRows = '';
            let awayRows = '';

            // Render starters
            const maxStarters = Math.max(homeStarters.length, awayStarters.length);
            for (let i = 0; i < maxStarters; i++) {
                homeRows += renderHomePlayerRow(homeStarters[i]);
                awayRows += renderAwayPlayerRow(awayStarters[i]);
            }

            // Add divider if there are subs
            if (homeSubs.length > 0 || awaySubs.length > 0) {
                homeRows += '<div class="team-divider">Substitutes</div>';
                awayRows += '<div class="team-divider">Substitutes</div>';
            }

            // Render subs
            const maxSubs = Math.max(homeSubs.length, awaySubs.length);
            for (let i = 0; i < maxSubs; i++) {
                homeRows += renderHomePlayerRow(homeSubs[i]);
                awayRows += renderAwayPlayerRow(awaySubs[i]);
            }

            // Build Defensive Contribution table
            // Defcon threshold: 10 for DEF, 12 for MID/FWD (no defcons for GKP)
            const getDefconThreshold = (position) => position === 'DEF' ? 10 : 12;
            const hasReachedDefconThreshold = (p) => {
                if (p.position === 'GKP') return false;
                return p.defcon >= getDefconThreshold(p.position);
            };

            const homeDefcons = homePlayers.filter(p => p.defcon > 0)
                .sort((a, b) => (b.defcon || 0) - (a.defcon || 0));
            const awayDefcons = awayPlayers.filter(p => p.defcon > 0)
                .sort((a, b) => (b.defcon || 0) - (a.defcon || 0));

            let dcHtml = '';
            if (homeDefcons.length > 0 || awayDefcons.length > 0) {
                const maxDcRows = Math.max(homeDefcons.length, awayDefcons.length);
                let dcRows = '';

                for (let i = 0; i < Math.min(maxDcRows, 12); i++) {
                    const homeP = homeDefcons[i];
                    const awayP = awayDefcons[i];

                    const homeAchieved = homeP && hasReachedDefconThreshold(homeP);
                    const awayAchieved = awayP && hasReachedDefconThreshold(awayP);

                    const homeCell = homeP ? `
                        <div class="stats-table-col home">
                            <span class="stats-player-name">${homeP.name}${homeAchieved ? ' ðŸ”’' : ''}</span>
                            <span class="dc-value${homeAchieved ? ' achieved' : ''}">${homeP.defcon}</span>
                        </div>
                    ` : '<div class="stats-table-col home"></div>';

                    const awayCell = awayP ? `
                        <div class="stats-table-col away">
                            <span class="dc-value${awayAchieved ? ' achieved' : ''}">${awayP.defcon}</span>
                            <span class="stats-player-name">${awayAchieved ? 'ðŸ”’ ' : ''}${awayP.name}</span>
                        </div>
                    ` : '<div class="stats-table-col away"></div>';

                    dcRows += `<div class="stats-table-row">${homeCell}${awayCell}</div>`;
                }

                dcHtml = `
                    <div class="stats-table-section">
                        <div class="stats-table-header">
                            <span>ðŸ›¡ï¸</span> Defensive Contribution
                        </div>
                        <div class="stats-table">${dcRows}</div>
                    </div>
                `;
            }

            // Build Keeper Saves section - only show icon if 3+ saves (points milestone)
            const homeGK = homePlayers.find(p => p.position === 'GKP' && p.saves > 0);
            const awayGK = awayPlayers.find(p => p.position === 'GKP' && p.saves > 0);

            let savesHtml = '';
            if (homeGK || awayGK) {
                // Calculate save points milestones (3 saves = 1 pt, 6 saves = 2 pts, etc.)
                const getSavesMilestones = (saves) => Math.floor(saves / 3);

                const homeCell = homeGK ? `
                    <div class="stats-table-col home">
                        <span class="stats-player-name">${homeGK.name}${getSavesMilestones(homeGK.saves) > 0 ? ' ðŸ§¤' : ''}${getSavesMilestones(homeGK.saves) > 1 ? `<span class="icon-count">${getSavesMilestones(homeGK.saves)}</span>` : ''}</span>
                        <span class="saves-value${getSavesMilestones(homeGK.saves) > 0 ? ' achieved' : ''}">${homeGK.saves}</span>
                    </div>
                ` : '<div class="stats-table-col home"></div>';

                const awayCell = awayGK ? `
                    <div class="stats-table-col away">
                        <span class="saves-value${getSavesMilestones(awayGK.saves) > 0 ? ' achieved' : ''}">${awayGK.saves}</span>
                        <span class="stats-player-name">${getSavesMilestones(awayGK.saves) > 0 ? 'ðŸ§¤' : ''}${getSavesMilestones(awayGK.saves) > 1 ? `<span class="icon-count">${getSavesMilestones(awayGK.saves)}</span>` : ''} ${awayGK.name}</span>
                    </div>
                ` : '<div class="stats-table-col away"></div>';

                savesHtml = `
                    <div class="stats-table-section">
                        <div class="stats-table-header">
                            <span>ðŸ§¤</span> Keeper Saves
                        </div>
                        <div class="stats-table">
                            <div class="stats-table-row">${homeCell}${awayCell}</div>
                        </div>
                    </div>
                `;
            }

            // Build Bonus Points table - show BPS and earned bonus
            const playersWithBps = allPlayers.filter(p => p.bps > 0).sort((a, b) => b.bps - a.bps);

            let bpHtml = '';
            if (playersWithBps.length > 0) {
                // Calculate projected bonus
                const bpsValues = [...new Set(playersWithBps.map(p => p.bps))].sort((a, b) => b - a);
                const bonusMap = {};
                let currentRank = 1;

                for (const bpsVal of bpsValues) {
                    if (currentRank > 3) break;
                    const bonusForRank = currentRank === 1 ? 3 : currentRank === 2 ? 2 : currentRank === 3 ? 1 : 0;
                    if (bonusForRank === 0) break;
                    const playersAtThisBps = playersWithBps.filter(p => p.bps === bpsVal).length;
                    bonusMap[bpsVal] = bonusForRank;
                    currentRank += playersAtThisBps;
                }

                // Split into home and away for side-by-side, sorted by BPS within each team
                const homeBps = playersWithBps.filter(p => homePlayers.some(hp => hp.id === p.id)).slice(0, 12);
                const awayBps = playersWithBps.filter(p => awayPlayers.some(ap => ap.id === p.id)).slice(0, 12);
                const maxBpRows = Math.max(homeBps.length, awayBps.length);

                let bpRows = '';
                for (let i = 0; i < Math.min(maxBpRows, 12); i++) {
                    const homeP = homeBps[i];
                    const awayP = awayBps[i];

                    const homeBonus = homeP ? (bonusMap[homeP.bps] || 0) : 0;
                    const awayBonus = awayP ? (bonusMap[awayP.bps] || 0) : 0;

                    const homeCell = homeP ? `
                        <div class="stats-table-col home">
                            <span class="stats-player-name">${homeP.name}</span>
                            <span class="bp-value">${homeBonus > 0 ? `<span class="bp-earned">+${homeBonus}</span> ` : ''}[${homeP.bps}]</span>
                        </div>
                    ` : '<div class="stats-table-col home"></div>';

                    const awayCell = awayP ? `
                        <div class="stats-table-col away">
                            <span class="bp-value">[${awayP.bps}]${awayBonus > 0 ? ` <span class="bp-earned">+${awayBonus}</span>` : ''}</span>
                            <span class="stats-player-name">${awayP.name}</span>
                        </div>
                    ` : '<div class="stats-table-col away"></div>';

                    bpRows += `<div class="stats-table-row">${homeCell}${awayCell}</div>`;
                }

                const bonusLabel = (data.finished || data.finishedProvisional) ? 'Bonus Points' : 'Projected Bonus';
                bpHtml = `
                    <div class="stats-table-section">
                        <div class="stats-table-header">
                            <span>â­</span> ${bonusLabel}
                        </div>
                        <div class="stats-table">${bpRows}</div>
                    </div>
                `;
            }

            const html = `
                <div class="teams-side-by-side">
                    <div class="team-column home">
                        <div class="team-column-header">${fixture.home}</div>
                        ${homeRows}
                    </div>
                    <div class="team-column away">
                        <div class="team-column-header">${fixture.away}</div>
                        ${awayRows}
                    </div>
                </div>
                <div class="stats-tables-container">
                    ${dcHtml}
                    ${savesHtml}
                    ${bpHtml}
                </div>
            `;

            document.getElementById('match-modal-body').innerHTML = html;
        }

        function closeModal(event) {
            if (event && event.target !== event.currentTarget) return;
            // Use history.back() to trigger popstate handler for proper history management
            window.history.back();
        }

        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                // Close the topmost modal via history
                const playerSheetOpen = document.getElementById('sheet-overlay').classList.contains('visible');
                const matchModalOpen = document.getElementById('match-modal-overlay').classList.contains('active');
                const fixturesModalOpen = document.getElementById('fixtures-modal-overlay').classList.contains('active');
                const managerModalOpen = document.getElementById('modal-overlay').classList.contains('active');

                if (playerSheetOpen || matchModalOpen || fixturesModalOpen || managerModalOpen) {
                    window.history.back();
                }
            }
        });

        window.addEventListener('resize', () => {
            isMobile = window.innerWidth < 768;
        });

        // Swipe gesture support for GW navigation
        let touchStartX = 0;
        let touchStartY = 0;
        let touchEndX = 0;
        let touchEndY = 0;
        const SWIPE_THRESHOLD = 50;

        function handleSwipe() {
            const diffX = touchStartX - touchEndX;
            const diffY = touchStartY - touchEndY;

            // Only trigger if primarily horizontal (X movement > Y movement)
            // This prevents vertical scrolling from triggering GW navigation
            if (Math.abs(diffX) < SWIPE_THRESHOLD) return;
            if (Math.abs(diffY) > Math.abs(diffX)) return;

            if (diffX > 0) {
                // Swipe left - go to next GW
                navigateGW(1);
            } else {
                // Swipe right - go to previous GW
                navigateGW(-1);
            }
        }

        document.getElementById('modal-overlay').addEventListener('touchstart', (e) => {
            touchStartX = e.changedTouches[0].screenX;
            touchStartY = e.changedTouches[0].screenY;
        }, { passive: true });

        document.getElementById('modal-overlay').addEventListener('touchend', (e) => {
            touchEndX = e.changedTouches[0].screenX;
            touchEndY = e.changedTouches[0].screenY;
            handleSwipe();
        }, { passive: true });

        // Handle URL parameters for deep linking (e.g., from losers page)
        let urlParamsProcessed = false;
        async function handleUrlParams() {
            // Only process once (not on refresh intervals)
            if (urlParamsProcessed) return;

            const params = new URLSearchParams(window.location.search);
            const entryId = params.get('entry');
            const targetGW = params.get('gw');
            const matchId = params.get('match');
            const view = params.get('view');

            if (entryId && weekData?.managers) {
                urlParamsProcessed = true;
                const manager = weekData.managers.find(m => m.entryId === parseInt(entryId));
                if (manager) {
                    // Open the modal
                    currentModalEntryId = parseInt(entryId);
                    currentModalGW = targetGW ? parseInt(targetGW) : weekData.currentGW;

                    document.getElementById('modal-manager-name').textContent = manager.name;
                    document.getElementById('modal-team-name').textContent = manager.team;
                    document.getElementById('gw-label').textContent = `GW ${currentModalGW}`;
                    document.getElementById('modal-body').innerHTML = '<div class="loading" style="padding: 2rem; color: #666;">Loading team...</div>';
                    document.getElementById('modal-overlay').classList.add('active');
                    document.body.style.overflow = 'hidden';

                    await loadModalData(parseInt(entryId), currentModalGW);

                    // Replace state to set modal state without adding extra history entry
                    // (the navigation from losers page already added a history entry)
                    window.history.replaceState(
                        { modal: 'manager', entryId: currentModalEntryId, gw: currentModalGW },
                        '',
                        window.location.href
                    );
                }
            } else if (matchId && weekData?.fixtures) {
                urlParamsProcessed = true;
                await openMatchModalFromHistory(parseInt(matchId));
                window.history.replaceState(
                    { modal: 'match', fixtureId: parseInt(matchId) },
                    '',
                    window.location.href
                );
            } else if (view === 'fixtures' && weekData?.fixtures) {
                urlParamsProcessed = true;
                openFixturesModalFromHistory();
                window.history.replaceState(
                    { modal: 'fixtures' },
                    '',
                    window.location.href
                );
            }
        }

        // ==========================================
        // Season (Standings) View Functions
        // ==========================================

        function switchView(view) {
            if (view === currentView) return;
            currentView = view;

            // Update toggle buttons
            document.getElementById('toggle-gw').classList.toggle('active', view === 'gw');
            document.getElementById('toggle-season').classList.toggle('active', view === 'season');
            document.getElementById('toggle-form').classList.toggle('active', view === 'form');

            // Update URL without adding history entry
            const url = new URL(window.location);
            if (view === 'season') {
                url.searchParams.set('view', 'season');
            } else if (view === 'form') {
                url.searchParams.set('view', 'form');
            } else {
                url.searchParams.delete('view');
            }
            window.history.replaceState(window.history.state, '', url.toString());

            // Clear any selected events
            selectedEventIdx = null;
            selectedChronoIdx = null;
            selectedChangeIdx = null;
            hideBonusPopup();
            document.querySelectorAll('.ticker-event').forEach(el => el.classList.remove('selected'));

            if (view === 'season') {
                renderSeasonView();
                // Load standings data if not already loaded
                if (standingsData.length === 0) {
                    loadStandingsData();
                }
            } else if (view === 'form') {
                renderFormView();
                loadFormData(formWeeks);
            } else {
                renderGWView();
            }
        }

        function renderGWView() {
            if (!weekData) return;

            let tickerHtml = buildTickerHtml(weekData);
            document.getElementById('ticker-area').innerHTML = tickerHtml;
            document.getElementById('content').innerHTML = `<div class="table-container"></div>`;
            renderTable();

            // Scroll ticker to show latest events
            const tickerTrack = document.getElementById('ticker-track');
            if (tickerTrack) {
                tickerTrack.scrollLeft = tickerTrack.scrollWidth;
            }
        }

        function renderSeasonView() {
            if (!weekData) return;

            let tickerHtml = buildTickerHtml(weekData);
            document.getElementById('ticker-area').innerHTML = tickerHtml;
            document.getElementById('content').innerHTML = `<div class="table-container standings-view">${standingsData.length > 0 ? '' : '<div class="loading">Loading standings...</div>'}</div>`;

            if (standingsData.length > 0) {
                renderStandingsTable(true);
            }

            // Scroll ticker to show latest events
            const tickerTrack = document.getElementById('ticker-track');
            if (tickerTrack) {
                tickerTrack.scrollLeft = tickerTrack.scrollWidth;
            }
        }

        async function loadStandingsData() {
            try {
                const res = await fetch('/api/standings' + (window.getSeasonParam ? window.getSeasonParam() : ''));
                if (!res.ok) throw new Error(`HTTP ${res.status}: ${res.statusText}`);
                const data = await res.json();

                standingsData = data.standings;
                standingsGW = data.currentGW || 0;

                if (currentView === 'season') {
                    const container = document.querySelector('.table-container');
                    if (container) {
                        container.innerHTML = '';
                        renderStandingsTable(true);
                    }
                }
            } catch (error) {
                const container = document.querySelector('.table-container');
                if (container) {
                    container.innerHTML = `<div class="loading">Error loading standings: ${error.message}</div>`;
                }
            }
        }

        // HTML escape helper
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function standingsSortClass(col) {
            if (standingsSort.col !== col) return '';
            return standingsSort.asc ? 'asc' : 'desc';
        }

        function sortStandingsTable(col) {
            if (standingsSort.col === col) {
                standingsSort.asc = !standingsSort.asc;
            } else {
                standingsSort.col = col;
                standingsSort.asc = true;
            }

            const sortKey = {
                'rank': p => p.rank,
                'manager': p => p.name.toLowerCase(),
                'gross': p => p.grossScore,
                'transfers': p => p.totalTransfers,
                'net': p => p.netScore
            }[col];

            standingsData.sort((a, b) => {
                const aVal = sortKey(a), bVal = sortKey(b);
                if (typeof aVal === 'string') return standingsSort.asc ? aVal.localeCompare(bVal) : bVal.localeCompare(aVal);
                return standingsSort.asc ? aVal - bVal : bVal - aVal;
            });

            renderStandingsTable();
        }

        function renderStandingsTable(animate) {
            const container = document.querySelector('.table-container');
            if (!container) return;

            let html = `
                <table>
                    <thead>
                        <tr>
                            <th style="width:7%" class="sortable ${standingsSortClass('rank')}" onclick="sortStandingsTable('rank')">#</th>
                            <th style="width:39%" class="col-manager sortable ${standingsSortClass('manager')}" onclick="sortStandingsTable('manager')">Manager</th>
                            <th style="width:17%" class="num sortable ${standingsSortClass('gross')}" onclick="sortStandingsTable('gross')">Gross</th>
                            <th style="width:16%" class="num sortable ${standingsSortClass('transfers')}" onclick="sortStandingsTable('transfers')">Xfr</th>
                            <th style="width:21%" class="num sortable ${standingsSortClass('net')}" onclick="sortStandingsTable('net')">Net</th>
                        </tr>
                    </thead>
                    <tbody>
            `;

            standingsData.forEach(player => {
                const rankClass = player.rank <= 3 ? `rank-${player.rank}` : '';
                const transfersDisplay = player.transferCost > 0
                    ? `${player.totalTransfers}<span class="transfer-cost" style="color: var(--danger)">-${player.transferCost}</span>`
                    : `${player.totalTransfers}`;

                // Event impact from ticker
                const impact = getStandingsEventImpact(player);
                let impactHtml = '';
                if (impact !== null && impact !== 0) {
                    const isPositive = impact >= 0;
                    const impactClass = isPositive ? 'positive' : 'negative';
                    const arrow = isPositive ? 'â–²' : 'â–¼';
                    impactHtml = `<span class="event-impact ${impactClass}"><span class="arrow">${arrow}</span>${Math.abs(impact)}</span>`;
                }

                const movementAttr = player.movement ? `data-movement="${player.movement}"` : '';

                html += `
                    <tr data-entry-id="${player.entryId}" ${movementAttr} onclick="openProfileModal(${player.entryId})">
                        <td class="rank-cell ${rankClass}">${player.rank}</td>
                        <td class="col-manager">
                            <strong>${escapeHtml(player.name)}</strong>
                            <div class="team-name">${escapeHtml(player.team)}</div>
                            <span class="info-pill value-pill">Â£${player.teamValue}m</span>
                        </td>
                        <td class="num">${player.grossScore}</td>
                        <td class="num">${transfersDisplay}</td>
                        <td class="num"><span class="badge badge-success">${player.netScore}</span>${impactHtml}</td>
                    </tr>
                `;
            });

            html += '</tbody></table>';
            container.innerHTML = html;

            if (animate) {
                animateStandingsMovement(container);
            }
        }

        function renderStandingsTableWithImpact(event, eventType) {
            const container = document.querySelector('.table-container');
            if (!container) return;

            let html = `
                <table>
                    <thead>
                        <tr>
                            <th style="width:7%" class="sortable ${standingsSortClass('rank')}" onclick="sortStandingsTable('rank')">#</th>
                            <th style="width:39%" class="col-manager sortable ${standingsSortClass('manager')}" onclick="sortStandingsTable('manager')">Manager</th>
                            <th style="width:17%" class="num sortable ${standingsSortClass('gross')}" onclick="sortStandingsTable('gross')">Gross</th>
                            <th style="width:16%" class="num sortable ${standingsSortClass('transfers')}" onclick="sortStandingsTable('transfers')">Xfr</th>
                            <th style="width:21%" class="num sortable ${standingsSortClass('net')}" onclick="sortStandingsTable('net')">Net</th>
                        </tr>
                    </thead>
                    <tbody>
            `;

            standingsData.forEach(player => {
                const rankClass = player.rank <= 3 ? `rank-${player.rank}` : '';
                const transfersDisplay = player.transferCost > 0
                    ? `${player.totalTransfers}<span class="transfer-cost" style="color: var(--danger)">-${player.transferCost}</span>`
                    : `${player.totalTransfers}`;

                // Calculate impact based on event type
                let impact = null;
                // Find matching weekData manager for this standings entry
                const weekManager = weekData?.managers?.find(m => m.entryId === player.entryId);
                if (weekManager) {
                    if (eventType === 'chrono') {
                        impact = getChronoEventImpactForManager(weekManager, event);
                    } else if (eventType === 'change') {
                        impact = getChangeEventImpactForManager(weekManager, event);
                    }
                }

                let impactHtml = '';
                if (impact !== null && impact !== 0) {
                    const isPositive = impact >= 0;
                    const impactClass = isPositive ? 'positive' : 'negative';
                    const arrow = isPositive ? 'â–²' : 'â–¼';
                    impactHtml = `<span class="event-impact ${impactClass}"><span class="arrow">${arrow}</span>${Math.abs(impact)}</span>`;
                }

                html += `
                    <tr data-entry-id="${player.entryId}" onclick="openProfileModal(${player.entryId})">
                        <td class="rank-cell ${rankClass}">${player.rank}</td>
                        <td class="col-manager">
                            <strong>${escapeHtml(player.name)}</strong>
                            <div class="team-name">${escapeHtml(player.team)}</div>
                            <span class="info-pill value-pill">Â£${player.teamValue}m</span>
                        </td>
                        <td class="num">${player.grossScore}</td>
                        <td class="num">${transfersDisplay}</td>
                        <td class="num"><span class="badge badge-success">${player.netScore}</span>${impactHtml}</td>
                    </tr>
                `;
            });

            html += '</tbody></table>';
            container.innerHTML = html;
        }

        // Get event impact for standings table rows using weekData managers
        function getStandingsEventImpact(standingsPlayer) {
            if (!weekData?.managers) return null;

            // Find the matching manager in weekData
            const manager = weekData.managers.find(m => m.entryId === standingsPlayer.entryId);
            if (!manager) return null;

            // Use the same impact calculation as the GW view
            return getEventImpactForManager(manager);
        }

        // ==========================================
        // Form View Functions
        // ==========================================

        function renderFormView() {
            if (!weekData) return;

            let tickerHtml = buildTickerHtml(weekData);
            document.getElementById('ticker-area').innerHTML = tickerHtml;

            document.getElementById('content').innerHTML = `
                <div class="form-toolbar" style="padding: 0 var(--space-4); display: flex; align-items: center; gap: 0.75rem; flex-shrink: 0;">
                    <label for="form-weeks-select" style="font-size: 0.8rem; color: rgba(255,255,255,0.7);">Last</label>
                    <select id="form-weeks-select" onchange="onFormWeeksChange(this.value)" style="
                        background: rgba(255,255,255,0.1);
                        border: 1px solid rgba(255,255,255,0.2);
                        color: var(--white);
                        padding: 0.35rem 0.5rem;
                        border-radius: 6px;
                        font-size: 0.8rem;
                        cursor: pointer;
                    ">
                        ${[3,5,8,10,15,20].map(n => `<option value="${n}" ${n === formWeeks ? 'selected' : ''}>${n}</option>`).join('')}
                    </select>
                    <span style="font-size: 0.8rem; color: rgba(255,255,255,0.7);">gameweeks</span>
                    <span id="form-gw-range" style="font-size: 0.7rem; color: rgba(255,255,255,0.4); margin-left: auto;"></span>
                </div>
                <div class="table-container form-view">${formData.length > 0 ? '' : '<div class="loading">Loading form data...</div>'}</div>`;

            if (formData.length > 0) {
                renderFormTable();
            }

            // Scroll ticker to show latest events
            const tickerTrack = document.getElementById('ticker-track');
            if (tickerTrack) {
                tickerTrack.scrollLeft = tickerTrack.scrollWidth;
            }
        }

        function onFormWeeksChange(val) {
            formWeeks = parseInt(val);
            loadFormData(formWeeks);
        }

        async function loadFormData(weeks) {
            if (formLoading) return;
            formLoading = true;

            const container = document.querySelector('.table-container.form-view');
            if (container && formData.length === 0) {
                container.innerHTML = '<div class="loading">Loading form data...</div>';
            }

            try {
                const res = await fetch('/api/form?weeks=' + weeks);
                if (!res.ok) throw new Error(`HTTP ${res.status}: ${res.statusText}`);
                const data = await res.json();

                formData = data.form;
                formTotalCompleted = data.totalCompleted;
                formSort = { col: null, asc: true };

                // Update GW range indicator
                const rangeEl = document.getElementById('form-gw-range');
                if (rangeEl && data.gwRange && data.gwRange.length > 0) {
                    rangeEl.textContent = `GW${data.gwRange[0]}\u2013GW${data.gwRange[data.gwRange.length - 1]}`;
                }

                if (currentView === 'form') {
                    const container = document.querySelector('.table-container.form-view');
                    if (container) {
                        container.innerHTML = '';
                        renderFormTable();
                    }
                }
            } catch (error) {
                const container = document.querySelector('.table-container.form-view');
                if (container) {
                    container.innerHTML = `<div class="loading">Error loading form data: ${error.message}</div>`;
                }
            } finally {
                formLoading = false;
            }
        }

        function formSortClass(col) {
            if (formSort.col !== col) return '';
            return formSort.asc ? 'asc' : 'desc';
        }

        function sortFormTable(col) {
            if (formSort.col === col) {
                formSort.asc = !formSort.asc;
            } else {
                formSort.col = col;
                formSort.asc = col === 'manager' ? true : false;
            }

            const sortKey = {
                'rank': p => p.rank,
                'manager': p => p.name.toLowerCase(),
                'gross': p => p.grossScore,
                'transfers': p => p.transfers,
                'cost': p => p.transferCost,
                'net': p => p.netScore
            }[col];

            formData.sort((a, b) => {
                const aVal = sortKey(a), bVal = sortKey(b);
                if (typeof aVal === 'string') return formSort.asc ? aVal.localeCompare(bVal) : bVal.localeCompare(aVal);
                return formSort.asc ? aVal - bVal : bVal - aVal;
            });

            renderFormTable();
        }

        function renderFormTable() {
            const container = document.querySelector('.table-container.form-view');
            if (!container) return;

            let html = `
                <table>
                    <thead>
                        <tr>
                            <th style="width:7%" class="sortable ${formSortClass('rank')}" onclick="sortFormTable('rank')">#</th>
                            <th style="width:33%" class="col-manager sortable ${formSortClass('manager')}" onclick="sortFormTable('manager')">Manager</th>
                            <th style="width:15%" class="num sortable ${formSortClass('gross')}" onclick="sortFormTable('gross')">Gross</th>
                            <th style="width:15%" class="num sortable ${formSortClass('transfers')}" onclick="sortFormTable('transfers')">Xfr</th>
                            <th style="width:12%" class="num sortable ${formSortClass('cost')}" onclick="sortFormTable('cost')">Cost</th>
                            <th style="width:18%" class="num sortable ${formSortClass('net')}" onclick="sortFormTable('net')">Net</th>
                        </tr>
                    </thead>
                    <tbody>
            `;

            formData.forEach(player => {
                const rankClass = player.rank <= 3 ? 'rank-' + player.rank : '';
                const costDisplay = player.transferCost > 0
                    ? '<span style="color: var(--danger)">-' + player.transferCost + '</span>'
                    : '0';

                html += '<tr>';
                html += '<td class="rank-cell ' + rankClass + '">' + player.rank + '</td>';
                html += '<td class="col-manager"><strong>' + escapeHtml(player.name) + '</strong><div class="team-name">' + escapeHtml(player.team) + '</div></td>';
                html += '<td class="num">' + player.grossScore + '</td>';
                html += '<td class="num">' + player.transfers + '</td>';
                html += '<td class="num">' + costDisplay + '</td>';
                html += '<td class="num"><span class="badge badge-success">' + player.netScore + '</span></td>';
                html += '</tr>';
            });

            html += '</tbody></table>';
            container.innerHTML = html;
        }

        // ==========================================
        // Profile Modal Functions (from standings)
        // ==========================================

        function openProfileModal(entryId) {
            const manager = standingsData.find(m => m.entryId === entryId);
            if (!manager) return;
            const modal = document.getElementById('profileModal');
            document.getElementById('profileModalName').textContent = manager.name;
            document.getElementById('profileModalTeam').textContent = manager.team;
            document.getElementById('profileModalBody').innerHTML = '<div class="profile-modal-loading">Loading profile data...</div>';
            modal.classList.add('active');
            document.body.style.overflow = 'hidden';
            currentProfileEntryId = entryId;

            // Push to browser history for back button support
            pushModalState('profile', { entryId });

            fetchProfileData(entryId);
        }

        function closeProfileModal() {
            const modal = document.getElementById('profileModal');
            if (!modal.classList.contains('active')) return;
            window.history.back();
        }

        // Close profile modal on overlay click
        document.getElementById('profileModal').addEventListener('click', function(e) {
            if (e.target === this) closeProfileModal();
        });

        async function fetchProfileData(entryId) {
            try {
                const res = await fetch(`/api/manager/${entryId}/profile`);
                if (!res.ok) throw new Error(`HTTP ${res.status}: ${res.statusText}`);
                const data = await res.json();

                if (data.error) {
                    document.getElementById('profileModalBody').innerHTML = `<div class="profile-modal-loading" style="color: var(--danger);">${data.error}</div>`;
                    return;
                }

                renderProfileData(data);
            } catch (error) {
                document.getElementById('profileModalBody').innerHTML = `<div class="profile-modal-loading" style="color: var(--danger);">Error loading profile: ${error.message}</div>`;
            }
        }

        function renderProfileData(data) {
            const { records, loserCount, motmWins, history } = data;
            const currentLeagueRank = records.currentRank || standingsData.find(s => s.entryId === data.entryId)?.rank || '-';

            const html = `
                <div class="profile-quick-stats">
                    <div class="profile-stat-box">
                        <div class="profile-stat-value">#${currentLeagueRank}</div>
                        <div class="profile-stat-label">League Rank</div>
                        <div class="profile-stat-sub">(best: #${records.bestRank || '-'})</div>
                    </div>
                    <div class="profile-stat-box">
                        <div class="profile-stat-value">${records.avgScore}</div>
                        <div class="profile-stat-label">Avg GW Score</div>
                    </div>
                    <div class="profile-stat-box">
                        <div class="profile-stat-value" style="color: ${motmWins > 0 ? 'var(--accent)' : 'var(--white)'}">${motmWins}</div>
                        <div class="profile-stat-label">MotM Wins</div>
                    </div>
                </div>
                <div class="profile-chart-section">
                    <h3>League Rank History</h3>
                    <div class="profile-chart-container">
                        <canvas id="profileRankChart"></canvas>
                    </div>
                </div>
                <div class="profile-stats-grid">
                    <div class="profile-stats-column">
                        <h3>Season Records</h3>
                        <ul class="profile-stats-list">
                            <li>
                                <span class="label">Best GW</span>
                                <span class="value highlight">${records.highestGW.points} pts <small>(GW${records.highestGW.gw})</small></span>
                            </li>
                            <li>
                                <span class="label">Worst GW</span>
                                <span class="value negative">${records.lowestGW.points} pts <small>(GW${records.lowestGW.gw})</small></span>
                            </li>
                            <li>
                                <span class="label">Weekly Loser</span>
                                <span class="value ${loserCount > 0 ? 'negative' : ''}">${loserCount}x</span>
                            </li>
                        </ul>
                    </div>
                    <div class="profile-stats-column">
                        <h3>Transfers</h3>
                        <ul class="profile-stats-list">
                            <li>
                                <span class="label">Total Made</span>
                                <span class="value">${records.totalTransfers}</span>
                            </li>
                            <li>
                                <span class="label">Point Hits</span>
                                <span class="value ${records.transferHits > 0 ? 'negative' : ''}">${records.transferHits > 0 ? '-' + records.transferHits + ' pts' : 'None'}</span>
                            </li>
                        </ul>
                    </div>
                </div>
            `;

            document.getElementById('profileModalBody').innerHTML = html;
            renderProfileRankChart(history);
        }

        function renderProfileRankChart(history) {
            const ctx = document.getElementById('profileRankChart').getContext('2d');
            const labels = history.map(h => `GW${h.gw}`);
            const ranks = history.map(h => h.rank);
            const maxRank = Math.max(...ranks, 29);

            if (rankChart) {
                rankChart.destroy();
            }

            rankChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'League Rank',
                        data: ranks,
                        borderColor: '#00ff87',
                        backgroundColor: 'rgba(0, 255, 135, 0.1)',
                        fill: true,
                        tension: 0.3,
                        pointRadius: 3,
                        pointBackgroundColor: '#00ff87',
                        pointBorderColor: '#00ff87',
                        pointHoverRadius: 6
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            backgroundColor: 'rgba(55, 0, 60, 0.9)',
                            titleColor: '#fff',
                            bodyColor: '#00ff87',
                            borderColor: '#00ff87',
                            borderWidth: 1,
                            callbacks: {
                                label: function(context) {
                                    return 'Rank: #' + context.raw;
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            reverse: true,
                            min: 1,
                            max: maxRank,
                            ticks: { stepSize: 5, color: 'rgba(255,255,255,0.5)' },
                            grid: { color: 'rgba(255,255,255,0.1)' }
                        },
                        x: {
                            ticks: {
                                color: 'rgba(255,255,255,0.5)',
                                maxRotation: 0,
                                callback: function(val, index) {
                                    return index % 5 === 0 ? this.getLabelForValue(val) : '';
                                }
                            },
                            grid: { display: false }
                        }
                    }
                }
            });
        }

        // ==========================================
        // Update popstate handler for profile modal
        // ==========================================

        // Store original handlePopState and extend it
        const originalHandlePopState = handlePopState;

        function handlePopStateExtended(event) {
            const state = event.state || { modal: null };

            // Handle profile modal
            const profileModal = document.getElementById('profileModal');
            const profileModalOpen = profileModal.classList.contains('active');

            if (state.modal === 'profile' && state.entryId) {
                // Close other modals first
                originalHandlePopState(event);
                // Open profile modal
                const player = standingsData.find(p => p.entryId === state.entryId);
                if (player) {
                    document.getElementById('profileModalName').textContent = player.name;
                    document.getElementById('profileModalTeam').textContent = player.team;
                    document.getElementById('profileModalBody').innerHTML = '<div class="profile-modal-loading">Loading profile data...</div>';
                    profileModal.classList.add('active');
                    document.body.style.overflow = 'hidden';
                    currentProfileEntryId = state.entryId;
                    fetchProfileData(state.entryId);
                }
                return;
            }

            // Close profile modal if open
            if (profileModalOpen) {
                profileModal.classList.remove('active');
                document.body.style.overflow = '';
                if (rankChart) {
                    rankChart.destroy();
                    rankChart = null;
                }
                currentProfileEntryId = null;
            }

            // Delegate to original handler
            originalHandlePopState(event);
        }

        // Initialize modal history management first (registers handlePopState listener)
        initModalHistory();

        // Now replace with extended handler that also manages profile modal
        window.removeEventListener('popstate', handlePopState);
        window.addEventListener('popstate', handlePopStateExtended);

        // Also close profile modal and highlight popup on Escape
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                const highlightOverlay = document.getElementById('highlight-popup-overlay');
                if (highlightOverlay.classList.contains('active')) {
                    highlightOverlay.classList.remove('active');
                    return;
                }
                const profileModal = document.getElementById('profileModal');
                if (profileModal.classList.contains('active')) {
                    closeProfileModal();
                }
            }
        });

        loadWeekData();

        // After weekData loads, also load standings data and check for view param
        (function checkInitialView() {
            const params = new URLSearchParams(window.location.search);
            const viewParam = params.get('view');
            if (viewParam === 'season' || viewParam === 'form') {
                // Will switch to the requested view after data loads
                const waitForData = setInterval(() => {
                    if (weekData) {
                        clearInterval(waitForData);
                        switchView(viewParam);
                    }
                }, 100);
            } else {
                // Pre-load standings in background
                loadStandingsData();
            }
        })();
    </script>
</body>
</html>
